{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"VirConv Module Extraction \u6587\u6863 \u00b6 \ud83d\ude80 VirConv Module Extraction \u662f\u4e00\u4e2a\u9762\u5411\u4e09\u7ef4\u611f\u77e5\u4efb\u52a1\u7684\u6a21\u5757\u5316\u7b97\u5b50\u6846\u67b6\u793a\u4f8b\u9879\u76ee\uff0c \u8be5\u9879\u76ee\u4ee5 VirConv\uff08Virtual Sparse Convolution\uff09 \u65b9\u6cd5\u4e3a\u6838\u5fc3\uff0c\u5bf9\u5176\u8ba1\u7b97\u6d41\u7a0b\u8fdb\u884c \u7b97\u5b50\u7ea7\u62c6\u89e3\u4e0e\u91cd\u6784 \uff0c \u5e76\u901a\u8fc7\u7edf\u4e00\u7684 Framework \u7ec4\u7ec7\u6267\u884c\uff0c\u4fbf\u4e8e\u7406\u89e3\u3001\u590d\u73b0\u4e0e\u4e8c\u6b21\u5f00\u53d1\u3002 \u9879\u76ee\u6574\u4f53\u7ed3\u6784 \u00b6 VirConv \u7684\u8ba1\u7b97\u6d41\u7a0b\u88ab\u5212\u5206\u4e3a\u4e24\u4e2a\u4e3b\u8981\u9636\u6bb5\uff1a Voxel Preparation Stage \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u878d\u5408 \u70b9\u7ea7 / \u4f53\u7d20\u7ea7\u51e0\u4f55\u5904\u7406 \u4e3a\u540e\u7eed VirConv Block \u6784\u5efa\u6807\u51c6\u8f93\u5165 VirConv Block Stage STVD Layer\uff08\u865a\u62df\u70b9\u7b5b\u9009\u4e0e\u52a0\u6743\uff09 \u6295\u5f71\u4e0e\u975e\u89c4\u5219\u5377\u79ef \u591a\u6a21\u6001\u7279\u5f81\u878d\u5408\u4e0e\u589e\u5f3a \u6700\u7ec8\u8f93\u51fa\u4e3a \u878d\u5408\u540e\u7684\u7a00\u758f\u4f53\u7d20\u7279\u5f81 \uff0c\u53ef\u5bf9\u63a5\u4e0b\u6e38 3D \u68c0\u6d4b\u5934\u3002 \u6587\u6863\u5bfc\u822a\uff08\u6838\u5fc3\u5185\u5bb9\uff09 \u00b6 \u4ee5\u4e0b\u6587\u6863\u7531 \u4ee3\u7801\u6ce8\u91ca\u81ea\u52a8\u751f\u6210\u6216\u6574\u7406 \uff0c\u5efa\u8bae\u6309\u987a\u5e8f\u9605\u8bfb\uff1a \ud83d\udcd8 VoxelPreparationStage \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u7684\u9884\u5904\u7406\u9636\u6bb5\uff0c\u5305\u542b\u4f53\u7d20\u5316\u3001\u5bf9\u9f50\u3001\u8ddd\u79bb\u5206\u7bb1\u7b49\u7b97\u5b50\u3002 \ud83d\udcd7 VirConvStage VirConv Block \u6838\u5fc3\u9636\u6bb5\uff0c\u5305\u542b STVD Layer\u3001Projection\u3001NRConv \u4e0e SparseConv\u3002 \ud83d\udcd9 Framework VirConvFramework \u7684\u6574\u4f53\u8bbe\u8ba1\u4e0e\u524d\u5411\u6267\u884c\u6d41\u7a0b\u8bf4\u660e\u3002","title":"\u6587\u6863\u9996\u9875"},{"location":"#virconv-module-extraction","text":"\ud83d\ude80 VirConv Module Extraction \u662f\u4e00\u4e2a\u9762\u5411\u4e09\u7ef4\u611f\u77e5\u4efb\u52a1\u7684\u6a21\u5757\u5316\u7b97\u5b50\u6846\u67b6\u793a\u4f8b\u9879\u76ee\uff0c \u8be5\u9879\u76ee\u4ee5 VirConv\uff08Virtual Sparse Convolution\uff09 \u65b9\u6cd5\u4e3a\u6838\u5fc3\uff0c\u5bf9\u5176\u8ba1\u7b97\u6d41\u7a0b\u8fdb\u884c \u7b97\u5b50\u7ea7\u62c6\u89e3\u4e0e\u91cd\u6784 \uff0c \u5e76\u901a\u8fc7\u7edf\u4e00\u7684 Framework \u7ec4\u7ec7\u6267\u884c\uff0c\u4fbf\u4e8e\u7406\u89e3\u3001\u590d\u73b0\u4e0e\u4e8c\u6b21\u5f00\u53d1\u3002","title":"VirConv Module Extraction \u6587\u6863"},{"location":"#_1","text":"VirConv \u7684\u8ba1\u7b97\u6d41\u7a0b\u88ab\u5212\u5206\u4e3a\u4e24\u4e2a\u4e3b\u8981\u9636\u6bb5\uff1a Voxel Preparation Stage \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u878d\u5408 \u70b9\u7ea7 / \u4f53\u7d20\u7ea7\u51e0\u4f55\u5904\u7406 \u4e3a\u540e\u7eed VirConv Block \u6784\u5efa\u6807\u51c6\u8f93\u5165 VirConv Block Stage STVD Layer\uff08\u865a\u62df\u70b9\u7b5b\u9009\u4e0e\u52a0\u6743\uff09 \u6295\u5f71\u4e0e\u975e\u89c4\u5219\u5377\u79ef \u591a\u6a21\u6001\u7279\u5f81\u878d\u5408\u4e0e\u589e\u5f3a \u6700\u7ec8\u8f93\u51fa\u4e3a \u878d\u5408\u540e\u7684\u7a00\u758f\u4f53\u7d20\u7279\u5f81 \uff0c\u53ef\u5bf9\u63a5\u4e0b\u6e38 3D \u68c0\u6d4b\u5934\u3002","title":"\u9879\u76ee\u6574\u4f53\u7ed3\u6784"},{"location":"#_2","text":"\u4ee5\u4e0b\u6587\u6863\u7531 \u4ee3\u7801\u6ce8\u91ca\u81ea\u52a8\u751f\u6210\u6216\u6574\u7406 \uff0c\u5efa\u8bae\u6309\u987a\u5e8f\u9605\u8bfb\uff1a \ud83d\udcd8 VoxelPreparationStage \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u7684\u9884\u5904\u7406\u9636\u6bb5\uff0c\u5305\u542b\u4f53\u7d20\u5316\u3001\u5bf9\u9f50\u3001\u8ddd\u79bb\u5206\u7bb1\u7b49\u7b97\u5b50\u3002 \ud83d\udcd7 VirConvStage VirConv Block \u6838\u5fc3\u9636\u6bb5\uff0c\u5305\u542b STVD Layer\u3001Projection\u3001NRConv \u4e0e SparseConv\u3002 \ud83d\udcd9 Framework VirConvFramework \u7684\u6574\u4f53\u8bbe\u8ba1\u4e0e\u524d\u5411\u6267\u884c\u6d41\u7a0b\u8bf4\u660e\u3002","title":"\u6587\u6863\u5bfc\u822a\uff08\u6838\u5fc3\u5185\u5bb9\uff09"},{"location":"VirConvStage/","text":"VirConv Stage\uff08VirConv Block\uff09 \u00b6 \u672c\u9636\u6bb5\u7684\u4f5c\u7528\u662f \u5728\u4f53\u7d20\u7ea7\u7279\u5f81\u4e0a\u6267\u884c VirConv Block \u7684\u6838\u5fc3\u8ba1\u7b97 \uff0c \u901a\u8fc7\u865a\u62df\u70b9\u7b5b\u9009\u3001\u51e0\u4f55\u6295\u5f71\u4e0e\u975e\u89c4\u5219\u5377\u79ef\uff0c\u5b9e\u73b0\u591a\u6a21\u6001\u4f53\u7d20\u7279\u5f81\u7684\u6df1\u5ea6\u878d\u5408\u3002 \u672c\u9636\u6bb5\u5305\u542b\u4ee5\u4e0b\u7b97\u5b50\u4e0e\u6a21\u5757\uff1a stvd_layer \u57fa\u4e8e STVD \u673a\u5236\u5bf9\u865a\u62df\u70b9\u8fdb\u884c\u7b5b\u9009\u4e0e\u52a0\u6743\u3002 projection \u5c06\u4f53\u7d20\u6216\u865a\u62df\u70b9\u4ece 3D \u7a7a\u95f4\u6295\u5f71\u5230 2D \u56fe\u50cf\u5e73\u9762\u3002 NRConv3D \u5728\u7a00\u758f\u4f53\u7d20\u7ed3\u6784\u4e0a\u6267\u884c\u975e\u89c4\u5219 3D \u5377\u79ef\u3002 NRConv2D \u5728\u6295\u5f71\u540e\u7684 2D \u5e73\u9762\u4e0a\u6267\u884c\u975e\u89c4\u5219 2D \u5377\u79ef\u3002 SparseConv3D \u8fdb\u4e00\u6b65\u5bf9\u4f53\u7d20\u7279\u5f81\u8fdb\u884c\u7a00\u758f 3D \u5377\u79ef\u589e\u5f3a\u3002 FeatureFusion \u878d\u5408\u6765\u81ea\u4e0d\u540c\u5206\u652f\u7684\u4f53\u7d20\u7279\u5f81\uff0c\u8f93\u51fa\u6700\u7ec8\u878d\u5408\u8868\u793a\u3002 API \u6587\u6863 \u00b6 stvd_layer \u00b6 stvd_layer ( voxel_coords , voxel_features , discard_rate , training ) \u00b6 \u5bf9\u4e2d\u95f4\u5c42\u4f53\u7d20\u6267\u884c\u968f\u673a\u4e22\u5f03\uff08Layer StVD\uff09\uff0c\u7528\u4e8e\u589e\u5f3a\u7a00\u758f\u9c81\u68d2\u6027\u3002 Parameters: voxel_coords ( Tensor ) \u2013 (M, 3) \u8f93\u5165\u4f53\u7d20\u5750\u6807\u7d22\u5f15\u3002 voxel_features ( Tensor ) \u2013 (M, C) \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u3002 discard_rate ( float ) \u2013 float \u4e22\u5f03\u6bd4\u4f8b\uff0c\u53d6\u503c\u8303\u56f4 [0, 1)\u3002 training ( bool ) \u2013 bool \u662f\u5426\u8bad\u7ec3\u9636\u6bb5\uff1b\u63a8\u7406\u9636\u6bb5\u4e0d\u6267\u884c\u4e22\u5f03\u3002 Returns: voxel_coords_kept ( Tensor ) \u2013 (M', 3) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u5750\u6807\u3002 voxel_features_kept ( Tensor ) \u2013 (M', C) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u7279\u5f81\u3002 Source code in VirConvBlockStage\\operator\\stvd_layer.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @torch . library . custom_op ( \"virconv::stvd_layer\" , mutates_args = []) def stvd_layer ( voxel_coords : torch . Tensor , voxel_features : torch . Tensor , discard_rate : float , training : bool ) -> Tuple [ torch . Tensor , torch . Tensor ]: \"\"\" \u5bf9\u4e2d\u95f4\u5c42\u4f53\u7d20\u6267\u884c\u968f\u673a\u4e22\u5f03\uff08Layer StVD\uff09\uff0c\u7528\u4e8e\u589e\u5f3a\u7a00\u758f\u9c81\u68d2\u6027\u3002 Args: voxel_coords: (M, 3) \u8f93\u5165\u4f53\u7d20\u5750\u6807\u7d22\u5f15\u3002 voxel_features: (M, C) \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u3002 discard_rate: float \u4e22\u5f03\u6bd4\u4f8b\uff0c\u53d6\u503c\u8303\u56f4 [0, 1)\u3002 training: bool \u662f\u5426\u8bad\u7ec3\u9636\u6bb5\uff1b\u63a8\u7406\u9636\u6bb5\u4e0d\u6267\u884c\u4e22\u5f03\u3002 Returns: voxel_coords_kept: (M', 3) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u5750\u6807\u3002 voxel_features_kept: (M', C) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u7279\u5f81\u3002 \"\"\" if voxel_coords . ndim != 2 or voxel_coords . shape [ 1 ] != 3 : raise ValueError ( f \"voxel_coords must be (M,3), got { voxel_coords . shape } \" ) if voxel_features . ndim != 2 : raise ValueError ( f \"voxel_features must be (M,C), got { voxel_features . shape } \" ) if voxel_coords . shape [ 0 ] != voxel_features . shape [ 0 ]: raise ValueError ( \"voxel_coords and voxel_features must have same length\" ) # \u63a8\u7406\u9636\u6bb5\u6216\u4e0d\u4e22\u5f03\uff1a\u4e5f\u5fc5\u987b\u8fd4\u56de clone\uff08custom_op \u7981\u6b62 alias\uff09 if ( not training ) or discard_rate <= 0.0 : return voxel_coords . clone (), voxel_features . clone () # \u6781\u7aef\u60c5\u51b5\uff1a\u5168\u4e22\u5f03 if discard_rate >= 1.0 : empty_coords = voxel_coords [: 0 ] . clone () empty_feats = voxel_features [: 0 ] . clone () return empty_coords , empty_feats keep_prob = 1.0 - float ( discard_rate ) rand = torch . rand (( voxel_coords . shape [ 0 ],), device = voxel_coords . device , dtype = torch . float32 ) keep_mask = rand < keep_prob coords_kept = voxel_coords [ keep_mask ] . clone () feats_kept = voxel_features [ keep_mask ] . clone () return coords_kept , feats_kept projection \u00b6 projection ( voxel_coords , voxel_size , point_cloud_range , proj_matrix ) \u00b6 \u5c06\u4f53\u7d20\u5750\u6807\u6295\u5f71\u5230\u56fe\u50cf\u5e73\u9762\uff0c\u751f\u6210\u5bf9\u5e94\u7684 2D \u50cf\u7d20\u5750\u6807\u3002 Parameters: voxel_coords ( Tensor ) \u2013 (M, 3) \u4f53\u7d20\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_size ( Tensor ) \u2013 (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range ( Tensor ) \u2013 (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 proj_matrix ( Tensor ) \u2013 (3, 4) \u76f8\u673a\u6295\u5f71\u77e9\u9635\uff08K[R|t]\uff09\u3002 Returns: pixel_coords ( Tensor ) \u2013 (M, 2) \u6bcf\u4e2a\u4f53\u7d20\u4e2d\u5fc3\u5bf9\u5e94\u7684\u56fe\u50cf\u5e73\u9762\u50cf\u7d20\u5750\u6807 (u, v)\u3002 Source code in VirConvBlockStage\\operator\\projection.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @torch . library . custom_op ( \"virconv::projection\" , mutates_args = []) def projection ( voxel_coords : torch . Tensor , voxel_size : torch . Tensor , point_cloud_range : torch . Tensor , proj_matrix : torch . Tensor ) -> torch . Tensor : \"\"\" \u5c06\u4f53\u7d20\u5750\u6807\u6295\u5f71\u5230\u56fe\u50cf\u5e73\u9762\uff0c\u751f\u6210\u5bf9\u5e94\u7684 2D \u50cf\u7d20\u5750\u6807\u3002 Args: voxel_coords: (M, 3) \u4f53\u7d20\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_size: (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range: (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 proj_matrix: (3, 4) \u76f8\u673a\u6295\u5f71\u77e9\u9635\uff08K[R|t]\uff09\u3002 Returns: pixel_coords: (M, 2) \u6bcf\u4e2a\u4f53\u7d20\u4e2d\u5fc3\u5bf9\u5e94\u7684\u56fe\u50cf\u5e73\u9762\u50cf\u7d20\u5750\u6807 (u, v)\u3002 \"\"\" if voxel_coords . ndim != 2 or voxel_coords . shape [ 1 ] != 3 : raise ValueError ( f \"voxel_coords must be (M,3), got { voxel_coords . shape } \" ) device = voxel_coords . device # \u7edf\u4e00 device / dtype voxel_size = voxel_size . to ( device = device , dtype = torch . float32 ) point_cloud_range = point_cloud_range . to ( device = device , dtype = torch . float32 ) proj_matrix = proj_matrix . to ( device = device , dtype = torch . float32 ) pc_min = point_cloud_range [: 3 ] centers = ( voxel_coords . to ( torch . float32 ) + 0.5 ) * voxel_size + pc_min # (M,3) ones = torch . ones (( centers . shape [ 0 ], 1 ), device = device , dtype = torch . float32 ) centers_homo = torch . cat ([ centers , ones ], dim = 1 ) # (M,4) pixels_homo = centers_homo @ proj_matrix . t () # (M,3) pixels = pixels_homo [:, : 2 ] / pixels_homo [:, 2 : 3 ] . clamp_min ( 1e-6 ) return pixels . clone () # custom_op \u8f93\u51fa\u4e0d\u5141\u8bb8 alias NRConv3D \u00b6 NRConv3D \u00b6 Bases: Module NRConv 3D \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u6838\u5fc3\u53ef\u5b66\u4e60\u7b97\u5b50\u4e4b\u4e00\uff09\u3002 \u8be5\u6a21\u5757\u5728 \u4e09\u7ef4\u4f53\u7d20\u7a7a\u95f4 \u4e2d\u5bf9\u7a00\u758f\u4f53\u7d20\u7279\u5f81\u6267\u884c 3D \u5b50\u6d41\u5f62\u5377\u79ef\uff08Submanifold Sparse Convolution\uff09\uff0c \u7528\u4e8e\u5efa\u6a21\u4f53\u7d20\u5c40\u90e8\u90bb\u57df\u7684\u51e0\u4f55\u7ed3\u6784\u4e0e\u8bed\u4e49\u4fe1\u606f\u3002\u5176\u76ee\u6807\u4e0d\u662f\u6539\u53d8\u4f53\u7d20\u7684\u7a7a\u95f4\u5206\u5e03\uff0c \u800c\u662f\u5728 \u4fdd\u6301\u4f53\u7d20\u5750\u6807\u4e0d\u53d8 \u7684\u524d\u63d0\u4e0b\uff0c\u589e\u5f3a\u6bcf\u4e2a\u4f53\u7d20\u7684 3D \u8868\u8fbe\u80fd\u529b\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0cNRConv 3D \u662f \u8d28\u91cf\u5efa\u6a21\uff08Stage C\uff09 \u7684\u7b2c\u4e00\u6b65\uff0c \u4e3a\u540e\u7eed\u7684 2D \u6295\u5f71\u4e0e 2D NRConv \u63d0\u4f9b\u53ef\u9760\u7684\u4e09\u7ef4\u7279\u5f81\u57fa\u7840\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e \u53ef\u5b66\u4e60\u7b97\u5b50 \uff0c\u5176\u5377\u79ef\u6838\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u8fdb\u884c\u66f4\u65b0\u3002 \u7ed3\u6784\u8bf4\u660e \u00b6 Submanifold Sparse Conv3D \u5728\u4f53\u7d20 3D \u90bb\u57df\u5185\u8fdb\u884c\u5377\u79ef\u8ba1\u7b97 \u4e0d\u5f15\u5165\u65b0\u7684\u4f53\u7d20\uff0c\u4e0d\u6539\u53d8\u4f53\u7d20\u5750\u6807\u96c6\u5408 BatchNorm1d \u5bf9\u4f53\u7d20\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316\uff0c\u52a0\u901f\u6536\u655b ReLU \u6fc0\u6d3b \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b \u8f93\u5165 \u00b6 Args: voxel_features (torch.Tensor): \u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_in) - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6 \u8f93\u51fa \u00b6 Returns: torch.Tensor: \u66f4\u65b0\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_out) \u6a21\u5757\u7528\u9014 \u00b6 \u5efa\u6a21\u4f53\u7d20\u5728 3D \u7a7a\u95f4\u4e2d\u7684\u5c40\u90e8\u51e0\u4f55\u5173\u7cfb \u6291\u5236\u7531\u865a\u62df\u70b9\u5f15\u5165\u7684\u566a\u58f0\u7279\u5f81 \u4e3a\u540e\u7eed\u7684 2D \u6295\u5f71\u4e0e\u8de8\u6a21\u6001\u878d\u5408\u63d0\u4f9b\u9ad8\u8d28\u91cf 3D \u8868\u5f81 \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u7ec4\u6210\u90e8\u5206 Source code in VirConvBlockStage\\network\\NRConv3D.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class NRConv3D ( nn . Module ): \"\"\" NRConv 3D \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u6838\u5fc3\u53ef\u5b66\u4e60\u7b97\u5b50\u4e4b\u4e00\uff09\u3002 \u8be5\u6a21\u5757\u5728 **\u4e09\u7ef4\u4f53\u7d20\u7a7a\u95f4** \u4e2d\u5bf9\u7a00\u758f\u4f53\u7d20\u7279\u5f81\u6267\u884c 3D \u5b50\u6d41\u5f62\u5377\u79ef\uff08Submanifold Sparse Convolution\uff09\uff0c \u7528\u4e8e\u5efa\u6a21\u4f53\u7d20\u5c40\u90e8\u90bb\u57df\u7684\u51e0\u4f55\u7ed3\u6784\u4e0e\u8bed\u4e49\u4fe1\u606f\u3002\u5176\u76ee\u6807\u4e0d\u662f\u6539\u53d8\u4f53\u7d20\u7684\u7a7a\u95f4\u5206\u5e03\uff0c \u800c\u662f\u5728 **\u4fdd\u6301\u4f53\u7d20\u5750\u6807\u4e0d\u53d8** \u7684\u524d\u63d0\u4e0b\uff0c\u589e\u5f3a\u6bcf\u4e2a\u4f53\u7d20\u7684 3D \u8868\u8fbe\u80fd\u529b\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0cNRConv 3D \u662f **\u8d28\u91cf\u5efa\u6a21\uff08Stage C\uff09** \u7684\u7b2c\u4e00\u6b65\uff0c \u4e3a\u540e\u7eed\u7684 2D \u6295\u5f71\u4e0e 2D NRConv \u63d0\u4f9b\u53ef\u9760\u7684\u4e09\u7ef4\u7279\u5f81\u57fa\u7840\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e **\u53ef\u5b66\u4e60\u7b97\u5b50**\uff0c\u5176\u5377\u79ef\u6838\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u8fdb\u884c\u66f4\u65b0\u3002 --- ### \u7ed3\u6784\u8bf4\u660e 1. **Submanifold Sparse Conv3D** - \u5728\u4f53\u7d20 3D \u90bb\u57df\u5185\u8fdb\u884c\u5377\u79ef\u8ba1\u7b97 - \u4e0d\u5f15\u5165\u65b0\u7684\u4f53\u7d20\uff0c\u4e0d\u6539\u53d8\u4f53\u7d20\u5750\u6807\u96c6\u5408 2. **BatchNorm1d** - \u5bf9\u4f53\u7d20\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316\uff0c\u52a0\u901f\u6536\u655b 3. **ReLU \u6fc0\u6d3b** - \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b --- ### \u8f93\u5165 Args: voxel_features (torch.Tensor): \u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_in)** - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6 --- ### \u8f93\u51fa Returns: torch.Tensor: \u66f4\u65b0\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_out)** --- ### \u6a21\u5757\u7528\u9014 - \u5efa\u6a21\u4f53\u7d20\u5728 3D \u7a7a\u95f4\u4e2d\u7684\u5c40\u90e8\u51e0\u4f55\u5173\u7cfb - \u6291\u5236\u7531\u865a\u62df\u70b9\u5f15\u5165\u7684\u566a\u58f0\u7279\u5f81 - \u4e3a\u540e\u7eed\u7684 2D \u6295\u5f71\u4e0e\u8de8\u6a21\u6001\u878d\u5408\u63d0\u4f9b\u9ad8\u8d28\u91cf 3D \u8868\u5f81 - \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u7ec4\u6210\u90e8\u5206 \"\"\" def __init__ ( self , in_channels : int , out_channels : int ): super () . __init__ () # \u4f7f\u7528\u666e\u901a Linear \u8fd1\u4f3c SubMConv3D\uff08\u7b97\u5b50\u7ea7\u62bd\u8c61\u7248\u672c\uff09 # \u82e5\u63a5\u5165 spconv\uff0c\u53ef\u5728\u6b64\u5904\u66ff\u6362\u4e3a SubMConv3d self . linear = nn . Linear ( in_channels , out_channels , bias = False ) # 3D \u5377\u79ef\u7b49\u4ef7\u6620\u5c04 self . bn = nn . BatchNorm1d ( out_channels ) # \u6279\u5f52\u4e00\u5316 self . relu = nn . ReLU ( inplace = True ) # \u975e\u7ebf\u6027\u6fc0\u6d3b def forward ( self , voxel_features : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" x = self . linear ( voxel_features ) # \u7ebf\u6027\u6620\u5c04\uff08\u8fd1\u4f3c 3D SubMConv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x forward ( voxel_features ) \u00b6 \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Parameters: voxel_features ( Tensor ) \u2013 \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: Tensor \u2013 torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) Source code in VirConvBlockStage\\network\\NRConv3D.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def forward ( self , voxel_features : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" x = self . linear ( voxel_features ) # \u7ebf\u6027\u6620\u5c04\uff08\u8fd1\u4f3c 3D SubMConv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x NRConv2D \u00b6 NRConv2D \u00b6 Bases: Module NRConv 2D \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u6838\u5fc3\u53ef\u5b66\u4e60\u7b97\u5b50\u4e4b\u4e00\uff09\u3002 \u8be5\u6a21\u5757\u5728 \u56fe\u50cf\u5e73\u9762\uff082D \u7a7a\u95f4\uff09 \u4e0a\u5bf9\u7531\u4f53\u7d20\u6295\u5f71\u5f97\u5230\u7684\u7279\u5f81\u6267\u884c 2D \u5377\u79ef\u5efa\u6a21\uff0c \u7528\u4e8e\u6355\u83b7\u4f53\u7d20\u5728\u56fe\u50cf\u89c6\u89d2\u4e0b\u7684\u5c40\u90e8\u4e0a\u4e0b\u6587\u4e0e\u8fb9\u754c\u4fe1\u606f\uff0c\u4ece\u800c\u8f85\u52a9\u5224\u65ad\u4f53\u7d20\u7279\u5f81\u7684\u53ef\u9760\u6027\u3002 \u4e0e NRConv 3D \u4e0d\u540c\uff0c\u672c\u6a21\u5757\u5173\u6ce8\u7684\u662f \u56fe\u50cf\u51e0\u4f55\u7ed3\u6784\u4e0e\u6df1\u5ea6\u4e0d\u8fde\u7eed\u6a21\u5f0f \u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0cNRConv 2D \u4f4d\u4e8e Projection \u4e4b\u540e\uff0c\u4e0e NRConv 3D \u5f62\u6210\u4e92\u8865\uff0c \u4e24\u8005\u7684\u8f93\u51fa\u5c06\u5728\u540e\u7eed Fusion \u7b97\u5b50\u4e2d\u8fdb\u884c\u878d\u5408\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e \u53ef\u5b66\u4e60\u7b97\u5b50 \uff0c\u5176\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u8fdb\u884c\u66f4\u65b0\u3002 \u7ed3\u6784\u8bf4\u660e \u00b6 2D Convolution\uff08kernel=3, padding=1\uff09 \u5728\u56fe\u50cf\u5e73\u9762\u90bb\u57df\u5185\u5efa\u6a21\u5c40\u90e8\u4e0a\u4e0b\u6587\u4fe1\u606f BatchNorm1d \u5bf9\u4f53\u7d20\u7ea7\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316 ReLU \u6fc0\u6d3b \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b \u8f93\u5165 \u00b6 Args: voxel_features (torch.Tensor): \u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_in) - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6 pixel_coords (torch.Tensor): \u6295\u5f71\u5f97\u5230\u7684 2D \u50cf\u7d20\u5750\u6807\uff0cshape \u4e3a (M, 2) - \u6bcf\u4e2a\u4f53\u7d20\u5728\u56fe\u50cf\u5e73\u9762\u4e2d\u7684\u4f4d\u7f6e (u, v) \u8f93\u51fa \u00b6 Returns: torch.Tensor: \u66f4\u65b0\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_out) \u6a21\u5757\u7528\u9014 \u00b6 \u4ece\u56fe\u50cf\u89c6\u89d2\u5efa\u6a21\u4f53\u7d20\u7684\u5c40\u90e8\u4e0a\u4e0b\u6587\u4fe1\u606f \u611f\u77e5\u6df1\u5ea6\u8865\u5168\u6216\u865a\u62df\u70b9\u5e26\u6765\u7684\u8fb9\u754c\u4e0e\u566a\u58f0\u6a21\u5f0f \u4e0e NRConv 3D \u5f62\u6210\u4e92\u8865\u7684\u8de8\u7a7a\u95f4\u7279\u5f81\u8868\u793a \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u7ec4\u6210\u90e8\u5206 Source code in VirConvBlockStage\\network\\NRConv2D.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class NRConv2D ( nn . Module ): \"\"\" NRConv 2D \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u6838\u5fc3\u53ef\u5b66\u4e60\u7b97\u5b50\u4e4b\u4e00\uff09\u3002 \u8be5\u6a21\u5757\u5728 **\u56fe\u50cf\u5e73\u9762\uff082D \u7a7a\u95f4\uff09** \u4e0a\u5bf9\u7531\u4f53\u7d20\u6295\u5f71\u5f97\u5230\u7684\u7279\u5f81\u6267\u884c 2D \u5377\u79ef\u5efa\u6a21\uff0c \u7528\u4e8e\u6355\u83b7\u4f53\u7d20\u5728\u56fe\u50cf\u89c6\u89d2\u4e0b\u7684\u5c40\u90e8\u4e0a\u4e0b\u6587\u4e0e\u8fb9\u754c\u4fe1\u606f\uff0c\u4ece\u800c\u8f85\u52a9\u5224\u65ad\u4f53\u7d20\u7279\u5f81\u7684\u53ef\u9760\u6027\u3002 \u4e0e NRConv 3D \u4e0d\u540c\uff0c\u672c\u6a21\u5757\u5173\u6ce8\u7684\u662f **\u56fe\u50cf\u51e0\u4f55\u7ed3\u6784\u4e0e\u6df1\u5ea6\u4e0d\u8fde\u7eed\u6a21\u5f0f**\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0cNRConv 2D \u4f4d\u4e8e Projection \u4e4b\u540e\uff0c\u4e0e NRConv 3D \u5f62\u6210\u4e92\u8865\uff0c \u4e24\u8005\u7684\u8f93\u51fa\u5c06\u5728\u540e\u7eed Fusion \u7b97\u5b50\u4e2d\u8fdb\u884c\u878d\u5408\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e **\u53ef\u5b66\u4e60\u7b97\u5b50**\uff0c\u5176\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u8fdb\u884c\u66f4\u65b0\u3002 --- ### \u7ed3\u6784\u8bf4\u660e 1. **2D Convolution\uff08kernel=3, padding=1\uff09** - \u5728\u56fe\u50cf\u5e73\u9762\u90bb\u57df\u5185\u5efa\u6a21\u5c40\u90e8\u4e0a\u4e0b\u6587\u4fe1\u606f 2. **BatchNorm1d** - \u5bf9\u4f53\u7d20\u7ea7\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316 3. **ReLU \u6fc0\u6d3b** - \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b --- ### \u8f93\u5165 Args: voxel_features (torch.Tensor): \u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_in)** - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6 pixel_coords (torch.Tensor): \u6295\u5f71\u5f97\u5230\u7684 2D \u50cf\u7d20\u5750\u6807\uff0cshape \u4e3a **(M, 2)** - \u6bcf\u4e2a\u4f53\u7d20\u5728\u56fe\u50cf\u5e73\u9762\u4e2d\u7684\u4f4d\u7f6e (u, v) --- ### \u8f93\u51fa Returns: torch.Tensor: \u66f4\u65b0\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_out)** --- ### \u6a21\u5757\u7528\u9014 - \u4ece\u56fe\u50cf\u89c6\u89d2\u5efa\u6a21\u4f53\u7d20\u7684\u5c40\u90e8\u4e0a\u4e0b\u6587\u4fe1\u606f - \u611f\u77e5\u6df1\u5ea6\u8865\u5168\u6216\u865a\u62df\u70b9\u5e26\u6765\u7684\u8fb9\u754c\u4e0e\u566a\u58f0\u6a21\u5f0f - \u4e0e NRConv 3D \u5f62\u6210\u4e92\u8865\u7684\u8de8\u7a7a\u95f4\u7279\u5f81\u8868\u793a - \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u7ec4\u6210\u90e8\u5206 \"\"\" def __init__ ( self , in_channels : int , out_channels : int ): super () . __init__ () # \u4f7f\u7528 Linear \u8fd1\u4f3c 2D \u5377\u79ef\uff08\u7b97\u5b50\u7ea7\u62bd\u8c61\u7248\u672c\uff09 # \u82e5\u6784\u5efa\u771f\u5b9e 2D feature map\uff0c\u53ef\u66ff\u6362\u4e3a nn.Conv2d self . linear = nn . Linear ( in_channels , out_channels , bias = False ) # 2D \u5377\u79ef\u7b49\u4ef7\u6620\u5c04 self . bn = nn . BatchNorm1d ( out_channels ) # \u6279\u5f52\u4e00\u5316 self . relu = nn . ReLU ( inplace = True ) # \u975e\u7ebf\u6027\u6fc0\u6d3b def forward ( self , voxel_features : torch . Tensor , pixel_coords : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) pixel_coords (torch.Tensor): \u6295\u5f71\u540e\u7684 2D \u50cf\u7d20\u5750\u6807\uff0cshape \u4e3a (M, 2) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" # \u5f53\u524d\u7b97\u5b50\u7ea7\u62bd\u8c61\u4e2d\uff0cpixel_coords \u4ec5\u4f5c\u4e3a\u51e0\u4f55\u5173\u8054\u8f93\u5165\uff0c\u4e0d\u76f4\u63a5\u53c2\u4e0e\u8ba1\u7b97 x = self . linear ( voxel_features ) # \u7279\u5f81\u6620\u5c04\uff08\u8fd1\u4f3c 2D Conv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x forward ( voxel_features , pixel_coords ) \u00b6 \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Parameters: voxel_features ( Tensor ) \u2013 \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) pixel_coords ( Tensor ) \u2013 \u6295\u5f71\u540e\u7684 2D \u50cf\u7d20\u5750\u6807\uff0cshape \u4e3a (M, 2) Returns: Tensor \u2013 torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) Source code in VirConvBlockStage\\network\\NRConv2D.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def forward ( self , voxel_features : torch . Tensor , pixel_coords : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) pixel_coords (torch.Tensor): \u6295\u5f71\u540e\u7684 2D \u50cf\u7d20\u5750\u6807\uff0cshape \u4e3a (M, 2) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" # \u5f53\u524d\u7b97\u5b50\u7ea7\u62bd\u8c61\u4e2d\uff0cpixel_coords \u4ec5\u4f5c\u4e3a\u51e0\u4f55\u5173\u8054\u8f93\u5165\uff0c\u4e0d\u76f4\u63a5\u53c2\u4e0e\u8ba1\u7b97 x = self . linear ( voxel_features ) # \u7279\u5f81\u6620\u5c04\uff08\u8fd1\u4f3c 2D Conv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x SparseConv3D \u00b6 SparseConv3D \u00b6 Bases: Module 3D SpConv \u6a21\u5757\uff08VirConv Backbone \u9636\u6bb5 D \u7684\u6838\u5fc3\u7ed3\u6784\u7b97\u5b50\uff09\u3002 \u8be5\u6a21\u5757\u5728 \u4e09\u7ef4\u4f53\u7d20\u7a7a\u95f4 \u4e2d\u5bf9\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\u6267\u884c\u7a00\u758f 3D \u5377\u79ef\uff0c \u7528\u4e8e\u8fdb\u884c \u7a7a\u95f4\u7ed3\u6784\u5efa\u6a21\u4e0e\u5c3a\u5ea6\u53d8\u6362 \u3002\u4e0e NRConv \u4e0d\u540c\uff0c \u672c\u6a21\u5757\u5141\u8bb8\u901a\u8fc7 stride \u5b9e\u73b0 \u4e0b\u91c7\u6837 \uff0c\u4ece\u800c\u6269\u5927\u611f\u53d7\u91ce\u5e76\u9010\u6b65\u6784\u5efa \u591a\u5c3a\u5ea6\u4e09\u7ef4\u7279\u5f81\u8868\u793a\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0c3D SpConv \u6807\u5fd7\u7740\u4ece \u878d\u5408\u5efa\u6a21\uff08Stage C\uff09 \u8fdb\u5165 Backbone \u7279\u5f81\u62bd\u8c61\uff08Stage D\uff09 \uff0c\u5176\u8f93\u51fa\u5c06\u4f5c\u4e3a\u4e0b\u4e00\u5c42 VirConv Block \u6216\u540e\u7eed\u7f51\u7edc\u6a21\u5757\u7684\u8f93\u5165\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e \u53ef\u5b66\u4e60\u7b97\u5b50 \uff0c\u5176\u5377\u79ef\u6838\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u66f4\u65b0\u3002 \u7ed3\u6784\u8bf4\u660e \u00b6 3D Sparse Convolution\uff08\u53ef\u5e26 stride\uff09 \u5728\u4f53\u7d20 3D \u90bb\u57df\u5185\u8fdb\u884c\u5377\u79ef\u8ba1\u7b97 \u53ef\u901a\u8fc7 stride > 1 \u5b9e\u73b0\u4f53\u7d20\u4e0b\u91c7\u6837 BatchNorm1d \u5bf9\u4f53\u7d20\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316\uff0c\u7a33\u5b9a\u8bad\u7ec3\u8fc7\u7a0b ReLU \u6fc0\u6d3b \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b \u8f93\u5165 \u00b6 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_in) - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u7279\u5f81\u7ef4\u5ea6 \u8f93\u51fa \u00b6 Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M', C_out) - M'\uff1a\u4e0b\u91c7\u6837\u540e\u4f53\u7d20\u6570\u91cf\uff08\u53ef\u80fd\u5c0f\u4e8e M\uff09 - C_out\uff1a\u8f93\u51fa\u7279\u5f81\u7ef4\u5ea6 \u6a21\u5757\u7528\u9014 \u00b6 \u6784\u5efa\u591a\u5c3a\u5ea6\u4e09\u7ef4\u7279\u5f81\u8868\u793a \u6269\u5927\u4f53\u7d20\u7279\u5f81\u7684\u7a7a\u95f4\u611f\u53d7\u91ce \u4e3a\u540e\u7eed\u68c0\u6d4b\u6216\u66f4\u9ad8\u5c42 Backbone \u63d0\u4f9b\u62bd\u8c61\u8bed\u4e49\u7279\u5f81 \u5c5e\u4e8e VirConv \u7684 Stage D\uff083D SpConv Backbone\uff09 Source code in VirConvBlockStage\\network\\SparseConv3D.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class SparseConv3D ( nn . Module ): \"\"\" 3D SpConv \u6a21\u5757\uff08VirConv Backbone \u9636\u6bb5 D \u7684\u6838\u5fc3\u7ed3\u6784\u7b97\u5b50\uff09\u3002 \u8be5\u6a21\u5757\u5728 **\u4e09\u7ef4\u4f53\u7d20\u7a7a\u95f4** \u4e2d\u5bf9\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\u6267\u884c\u7a00\u758f 3D \u5377\u79ef\uff0c \u7528\u4e8e\u8fdb\u884c **\u7a7a\u95f4\u7ed3\u6784\u5efa\u6a21\u4e0e\u5c3a\u5ea6\u53d8\u6362**\u3002\u4e0e NRConv \u4e0d\u540c\uff0c \u672c\u6a21\u5757\u5141\u8bb8\u901a\u8fc7 stride \u5b9e\u73b0 **\u4e0b\u91c7\u6837**\uff0c\u4ece\u800c\u6269\u5927\u611f\u53d7\u91ce\u5e76\u9010\u6b65\u6784\u5efa \u591a\u5c3a\u5ea6\u4e09\u7ef4\u7279\u5f81\u8868\u793a\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0c3D SpConv \u6807\u5fd7\u7740\u4ece **\u878d\u5408\u5efa\u6a21\uff08Stage C\uff09** \u8fdb\u5165 **Backbone \u7279\u5f81\u62bd\u8c61\uff08Stage D\uff09**\uff0c\u5176\u8f93\u51fa\u5c06\u4f5c\u4e3a\u4e0b\u4e00\u5c42 VirConv Block \u6216\u540e\u7eed\u7f51\u7edc\u6a21\u5757\u7684\u8f93\u5165\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e **\u53ef\u5b66\u4e60\u7b97\u5b50**\uff0c\u5176\u5377\u79ef\u6838\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u66f4\u65b0\u3002 --- ### \u7ed3\u6784\u8bf4\u660e 1. **3D Sparse Convolution\uff08\u53ef\u5e26 stride\uff09** - \u5728\u4f53\u7d20 3D \u90bb\u57df\u5185\u8fdb\u884c\u5377\u79ef\u8ba1\u7b97 - \u53ef\u901a\u8fc7 stride > 1 \u5b9e\u73b0\u4f53\u7d20\u4e0b\u91c7\u6837 2. **BatchNorm1d** - \u5bf9\u4f53\u7d20\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316\uff0c\u7a33\u5b9a\u8bad\u7ec3\u8fc7\u7a0b 3. **ReLU \u6fc0\u6d3b** - \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b --- ### \u8f93\u5165 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_in)** - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u7279\u5f81\u7ef4\u5ea6 --- ### \u8f93\u51fa Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M', C_out)** - M'\uff1a\u4e0b\u91c7\u6837\u540e\u4f53\u7d20\u6570\u91cf\uff08\u53ef\u80fd\u5c0f\u4e8e M\uff09 - C_out\uff1a\u8f93\u51fa\u7279\u5f81\u7ef4\u5ea6 --- ### \u6a21\u5757\u7528\u9014 - \u6784\u5efa\u591a\u5c3a\u5ea6\u4e09\u7ef4\u7279\u5f81\u8868\u793a - \u6269\u5927\u4f53\u7d20\u7279\u5f81\u7684\u7a7a\u95f4\u611f\u53d7\u91ce - \u4e3a\u540e\u7eed\u68c0\u6d4b\u6216\u66f4\u9ad8\u5c42 Backbone \u63d0\u4f9b\u62bd\u8c61\u8bed\u4e49\u7279\u5f81 - \u5c5e\u4e8e VirConv \u7684 Stage D\uff083D SpConv Backbone\uff09 \"\"\" def __init__ ( self , in_channels : int , out_channels : int , stride : int = 1 ): super () . __init__ () # \u4f7f\u7528 Linear \u8fd1\u4f3c 3D Sparse Convolution\uff08\u7b97\u5b50\u7ea7\u62bd\u8c61\u7248\u672c\uff09 # \u82e5\u63a5\u5165 spconv\uff0c\u53ef\u5728\u6b64\u5904\u66ff\u6362\u4e3a SparseConv3d / SubMConv3d self . linear = nn . Linear ( in_channels , out_channels , bias = False ) # \u7279\u5f81\u6620\u5c04 self . bn = nn . BatchNorm1d ( out_channels ) # \u6279\u5f52\u4e00\u5316 self . relu = nn . ReLU ( inplace = True ) # \u975e\u7ebf\u6027\u6fc0\u6d3b self . stride = stride # \u4e0b\u91c7\u6837\u6b65\u957f\uff08\u8bed\u4e49\u5360\u4f4d\uff09 def forward ( self , voxel_features : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M', C_out) \"\"\" # \u5f53\u524d\u7b97\u5b50\u7ea7\u62bd\u8c61\u4e2d\uff0cstride \u4e0d\u663e\u5f0f\u6539\u53d8\u5750\u6807\uff0c\u4ec5\u8868\u8fbe\u8bed\u4e49 x = self . linear ( voxel_features ) # \u7279\u5f81\u6620\u5c04\uff08\u8fd1\u4f3c 3D SpConv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x forward ( voxel_features ) \u00b6 \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Parameters: voxel_features ( Tensor ) \u2013 \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: Tensor \u2013 torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M', C_out) Source code in VirConvBlockStage\\network\\SparseConv3D.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def forward ( self , voxel_features : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M', C_out) \"\"\" # \u5f53\u524d\u7b97\u5b50\u7ea7\u62bd\u8c61\u4e2d\uff0cstride \u4e0d\u663e\u5f0f\u6539\u53d8\u5750\u6807\uff0c\u4ec5\u8868\u8fbe\u8bed\u4e49 x = self . linear ( voxel_features ) # \u7279\u5f81\u6620\u5c04\uff08\u8fd1\u4f3c 3D SpConv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x FeatureFusion \u00b6 FeatureFusion \u00b6 Bases: Module Feature Fusion \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u878d\u5408\u7b97\u5b50\uff09\u3002 \u8be5\u6a21\u5757\u7528\u4e8e\u878d\u5408 NRConv 3D \u4e0e NRConv 2D \u4e24\u6761\u5206\u652f\u8f93\u51fa\u7684\u4f53\u7d20\u7279\u5f81\uff0c \u5c06\u6765\u81ea\u4e09\u7ef4\u7a7a\u95f4\u4e0e\u56fe\u50cf\u5e73\u9762\u7684\u4e92\u8865\u4fe1\u606f\u6574\u5408\u4e3a\u7edf\u4e00\u7684\u4f53\u7d20\u7ea7\u8868\u793a\u3002 \u5176\u6838\u5fc3\u601d\u60f3\u662f\u5728 \u4e0d\u6539\u53d8\u4f53\u7d20\u7a7a\u95f4\u7ed3\u6784 \u7684\u524d\u63d0\u4e0b\uff0c\u5bf9\u540c\u4e00\u4f53\u7d20\u7684\u591a\u6e90\u7279\u5f81 \u8fdb\u884c\u901a\u9053\u7ea7\u878d\u5408\uff0c\u4ece\u800c\u83b7\u5f97\u66f4\u5177\u5224\u522b\u6027\u7684\u878d\u5408\u7279\u5f81\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0c\u672c\u7b97\u5b50\u4f4d\u4e8e NRConv (3D / 2D) \u4e4b\u540e\uff0c \u662f\u5b8c\u6210 \u8de8\u7a7a\u95f4\u4fe1\u606f\u6574\u5408 \u7684\u5173\u952e\u4e00\u6b65\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e \u53ef\u5b66\u4e60\u7b97\u5b50 \uff0c\u5176\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u6839\u636e\u76d1\u7763\u4fe1\u53f7\u8fdb\u884c\u66f4\u65b0\u3002 \u7ed3\u6784\u8bf4\u660e \u00b6 \u7279\u5f81\u62fc\u63a5\uff08Concat\uff09 \u5c06 3D \u4e0e 2D \u7279\u5f81\u5728\u901a\u9053\u7ef4\u5ea6\u8fdb\u884c\u62fc\u63a5 Linear \u6620\u5c04\uff08\u7b49\u4ef7\u4e8e 1\u00d71 Conv\uff09 \u5bf9\u62fc\u63a5\u540e\u7684\u7279\u5f81\u8fdb\u884c\u901a\u9053\u538b\u7f29\u4e0e\u91cd\u6620\u5c04 BatchNorm1d \u7a33\u5b9a\u7279\u5f81\u5206\u5e03\uff0c\u52a0\u901f\u8bad\u7ec3\u6536\u655b ReLU \u6fc0\u6d3b \u5f15\u5165\u975e\u7ebf\u6027\uff0c\u589e\u5f3a\u7279\u5f81\u8868\u8fbe\u80fd\u529b \u8f93\u5165 \u00b6 Args: feat_3d (torch.Tensor): \u6765\u81ea NRConv 3D \u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_3d) feat_2d (torch.Tensor): \u6765\u81ea NRConv 2D \u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_2d) \u8f93\u51fa \u00b6 Returns: torch.Tensor: \u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_out) \u6a21\u5757\u7528\u9014 \u00b6 \u878d\u5408\u4e09\u7ef4\u51e0\u4f55\u4fe1\u606f\u4e0e\u4e8c\u7ef4\u56fe\u50cf\u7ed3\u6784\u4fe1\u606f \u63d0\u5347\u4f53\u7d20\u7279\u5f81\u5bf9\u865a\u62df\u70b9\u566a\u58f0\u7684\u9c81\u68d2\u6027 \u4e3a\u540e\u7eed 3D SpConv Backbone \u63d0\u4f9b\u9ad8\u8d28\u91cf\u8f93\u5165\u7279\u5f81 \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u672b\u7aef\u878d\u5408\u7b97\u5b50 Source code in VirConvBlockStage\\network\\FeatureFusion.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class FeatureFusion ( nn . Module ): \"\"\" Feature Fusion \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u878d\u5408\u7b97\u5b50\uff09\u3002 \u8be5\u6a21\u5757\u7528\u4e8e\u878d\u5408 **NRConv 3D** \u4e0e **NRConv 2D** \u4e24\u6761\u5206\u652f\u8f93\u51fa\u7684\u4f53\u7d20\u7279\u5f81\uff0c \u5c06\u6765\u81ea\u4e09\u7ef4\u7a7a\u95f4\u4e0e\u56fe\u50cf\u5e73\u9762\u7684\u4e92\u8865\u4fe1\u606f\u6574\u5408\u4e3a\u7edf\u4e00\u7684\u4f53\u7d20\u7ea7\u8868\u793a\u3002 \u5176\u6838\u5fc3\u601d\u60f3\u662f\u5728 **\u4e0d\u6539\u53d8\u4f53\u7d20\u7a7a\u95f4\u7ed3\u6784** \u7684\u524d\u63d0\u4e0b\uff0c\u5bf9\u540c\u4e00\u4f53\u7d20\u7684\u591a\u6e90\u7279\u5f81 \u8fdb\u884c\u901a\u9053\u7ea7\u878d\u5408\uff0c\u4ece\u800c\u83b7\u5f97\u66f4\u5177\u5224\u522b\u6027\u7684\u878d\u5408\u7279\u5f81\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0c\u672c\u7b97\u5b50\u4f4d\u4e8e NRConv (3D / 2D) \u4e4b\u540e\uff0c \u662f\u5b8c\u6210 **\u8de8\u7a7a\u95f4\u4fe1\u606f\u6574\u5408** \u7684\u5173\u952e\u4e00\u6b65\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e **\u53ef\u5b66\u4e60\u7b97\u5b50**\uff0c\u5176\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u6839\u636e\u76d1\u7763\u4fe1\u53f7\u8fdb\u884c\u66f4\u65b0\u3002 --- ### \u7ed3\u6784\u8bf4\u660e 1. **\u7279\u5f81\u62fc\u63a5\uff08Concat\uff09** - \u5c06 3D \u4e0e 2D \u7279\u5f81\u5728\u901a\u9053\u7ef4\u5ea6\u8fdb\u884c\u62fc\u63a5 2. **Linear \u6620\u5c04\uff08\u7b49\u4ef7\u4e8e 1\u00d71 Conv\uff09** - \u5bf9\u62fc\u63a5\u540e\u7684\u7279\u5f81\u8fdb\u884c\u901a\u9053\u538b\u7f29\u4e0e\u91cd\u6620\u5c04 3. **BatchNorm1d** - \u7a33\u5b9a\u7279\u5f81\u5206\u5e03\uff0c\u52a0\u901f\u8bad\u7ec3\u6536\u655b 4. **ReLU \u6fc0\u6d3b** - \u5f15\u5165\u975e\u7ebf\u6027\uff0c\u589e\u5f3a\u7279\u5f81\u8868\u8fbe\u80fd\u529b --- ### \u8f93\u5165 Args: feat_3d (torch.Tensor): \u6765\u81ea NRConv 3D \u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a **(M, C_3d)** feat_2d (torch.Tensor): \u6765\u81ea NRConv 2D \u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a **(M, C_2d)** --- ### \u8f93\u51fa Returns: torch.Tensor: \u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_out)** --- ### \u6a21\u5757\u7528\u9014 - \u878d\u5408\u4e09\u7ef4\u51e0\u4f55\u4fe1\u606f\u4e0e\u4e8c\u7ef4\u56fe\u50cf\u7ed3\u6784\u4fe1\u606f - \u63d0\u5347\u4f53\u7d20\u7279\u5f81\u5bf9\u865a\u62df\u70b9\u566a\u58f0\u7684\u9c81\u68d2\u6027 - \u4e3a\u540e\u7eed 3D SpConv Backbone \u63d0\u4f9b\u9ad8\u8d28\u91cf\u8f93\u5165\u7279\u5f81 - \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u672b\u7aef\u878d\u5408\u7b97\u5b50 \"\"\" def __init__ ( self , in_channels_3d : int , in_channels_2d : int , out_channels : int ): super () . __init__ () in_channels = in_channels_3d + in_channels_2d # \u62fc\u63a5\u540e\u7684\u901a\u9053\u6570 self . linear = nn . Linear ( in_channels , out_channels , bias = False ) # \u901a\u9053\u878d\u5408\u6620\u5c04 self . bn = nn . BatchNorm1d ( out_channels ) # \u6279\u5f52\u4e00\u5316 self . relu = nn . ReLU ( inplace = True ) # \u975e\u7ebf\u6027\u6fc0\u6d3b def forward ( self , feat_3d : torch . Tensor , feat_2d : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: feat_3d (torch.Tensor): 3D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_3d) feat_2d (torch.Tensor): 2D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_2d) Returns: torch.Tensor: \u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" if feat_3d . shape [ 0 ] != feat_2d . shape [ 0 ]: # \u68c0\u67e5\u4f53\u7d20\u6570\u91cf\u4e00\u81f4 raise ValueError ( \"feat_3d and feat_2d must have the same number of voxels\" ) x = torch . cat ([ feat_3d , feat_2d ], dim = 1 ) # \u901a\u9053\u62fc\u63a5 x = self . linear ( x ) # \u901a\u9053\u878d\u5408\u6620\u5c04 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x forward ( feat_3d , feat_2d ) \u00b6 \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Parameters: feat_3d ( Tensor ) \u2013 3D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_3d) feat_2d ( Tensor ) \u2013 2D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_2d) Returns: Tensor \u2013 torch.Tensor: \u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) Source code in VirConvBlockStage\\network\\FeatureFusion.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def forward ( self , feat_3d : torch . Tensor , feat_2d : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: feat_3d (torch.Tensor): 3D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_3d) feat_2d (torch.Tensor): 2D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_2d) Returns: torch.Tensor: \u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" if feat_3d . shape [ 0 ] != feat_2d . shape [ 0 ]: # \u68c0\u67e5\u4f53\u7d20\u6570\u91cf\u4e00\u81f4 raise ValueError ( \"feat_3d and feat_2d must have the same number of voxels\" ) x = torch . cat ([ feat_3d , feat_2d ], dim = 1 ) # \u901a\u9053\u62fc\u63a5 x = self . linear ( x ) # \u901a\u9053\u878d\u5408\u6620\u5c04 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x","title":"VirConvStage"},{"location":"VirConvStage/#virconv-stagevirconv-block","text":"\u672c\u9636\u6bb5\u7684\u4f5c\u7528\u662f \u5728\u4f53\u7d20\u7ea7\u7279\u5f81\u4e0a\u6267\u884c VirConv Block \u7684\u6838\u5fc3\u8ba1\u7b97 \uff0c \u901a\u8fc7\u865a\u62df\u70b9\u7b5b\u9009\u3001\u51e0\u4f55\u6295\u5f71\u4e0e\u975e\u89c4\u5219\u5377\u79ef\uff0c\u5b9e\u73b0\u591a\u6a21\u6001\u4f53\u7d20\u7279\u5f81\u7684\u6df1\u5ea6\u878d\u5408\u3002 \u672c\u9636\u6bb5\u5305\u542b\u4ee5\u4e0b\u7b97\u5b50\u4e0e\u6a21\u5757\uff1a stvd_layer \u57fa\u4e8e STVD \u673a\u5236\u5bf9\u865a\u62df\u70b9\u8fdb\u884c\u7b5b\u9009\u4e0e\u52a0\u6743\u3002 projection \u5c06\u4f53\u7d20\u6216\u865a\u62df\u70b9\u4ece 3D \u7a7a\u95f4\u6295\u5f71\u5230 2D \u56fe\u50cf\u5e73\u9762\u3002 NRConv3D \u5728\u7a00\u758f\u4f53\u7d20\u7ed3\u6784\u4e0a\u6267\u884c\u975e\u89c4\u5219 3D \u5377\u79ef\u3002 NRConv2D \u5728\u6295\u5f71\u540e\u7684 2D \u5e73\u9762\u4e0a\u6267\u884c\u975e\u89c4\u5219 2D \u5377\u79ef\u3002 SparseConv3D \u8fdb\u4e00\u6b65\u5bf9\u4f53\u7d20\u7279\u5f81\u8fdb\u884c\u7a00\u758f 3D \u5377\u79ef\u589e\u5f3a\u3002 FeatureFusion \u878d\u5408\u6765\u81ea\u4e0d\u540c\u5206\u652f\u7684\u4f53\u7d20\u7279\u5f81\uff0c\u8f93\u51fa\u6700\u7ec8\u878d\u5408\u8868\u793a\u3002","title":"VirConv Stage\uff08VirConv Block\uff09"},{"location":"VirConvStage/#api","text":"","title":"API \u6587\u6863"},{"location":"VirConvStage/#stvd_layer","text":"","title":"stvd_layer"},{"location":"VirConvStage/#VirConvBlockStage.operator.stvd_layer.stvd_layer","text":"\u5bf9\u4e2d\u95f4\u5c42\u4f53\u7d20\u6267\u884c\u968f\u673a\u4e22\u5f03\uff08Layer StVD\uff09\uff0c\u7528\u4e8e\u589e\u5f3a\u7a00\u758f\u9c81\u68d2\u6027\u3002 Parameters: voxel_coords ( Tensor ) \u2013 (M, 3) \u8f93\u5165\u4f53\u7d20\u5750\u6807\u7d22\u5f15\u3002 voxel_features ( Tensor ) \u2013 (M, C) \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u3002 discard_rate ( float ) \u2013 float \u4e22\u5f03\u6bd4\u4f8b\uff0c\u53d6\u503c\u8303\u56f4 [0, 1)\u3002 training ( bool ) \u2013 bool \u662f\u5426\u8bad\u7ec3\u9636\u6bb5\uff1b\u63a8\u7406\u9636\u6bb5\u4e0d\u6267\u884c\u4e22\u5f03\u3002 Returns: voxel_coords_kept ( Tensor ) \u2013 (M', 3) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u5750\u6807\u3002 voxel_features_kept ( Tensor ) \u2013 (M', C) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u7279\u5f81\u3002 Source code in VirConvBlockStage\\operator\\stvd_layer.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @torch . library . custom_op ( \"virconv::stvd_layer\" , mutates_args = []) def stvd_layer ( voxel_coords : torch . Tensor , voxel_features : torch . Tensor , discard_rate : float , training : bool ) -> Tuple [ torch . Tensor , torch . Tensor ]: \"\"\" \u5bf9\u4e2d\u95f4\u5c42\u4f53\u7d20\u6267\u884c\u968f\u673a\u4e22\u5f03\uff08Layer StVD\uff09\uff0c\u7528\u4e8e\u589e\u5f3a\u7a00\u758f\u9c81\u68d2\u6027\u3002 Args: voxel_coords: (M, 3) \u8f93\u5165\u4f53\u7d20\u5750\u6807\u7d22\u5f15\u3002 voxel_features: (M, C) \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u3002 discard_rate: float \u4e22\u5f03\u6bd4\u4f8b\uff0c\u53d6\u503c\u8303\u56f4 [0, 1)\u3002 training: bool \u662f\u5426\u8bad\u7ec3\u9636\u6bb5\uff1b\u63a8\u7406\u9636\u6bb5\u4e0d\u6267\u884c\u4e22\u5f03\u3002 Returns: voxel_coords_kept: (M', 3) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u5750\u6807\u3002 voxel_features_kept: (M', C) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u7279\u5f81\u3002 \"\"\" if voxel_coords . ndim != 2 or voxel_coords . shape [ 1 ] != 3 : raise ValueError ( f \"voxel_coords must be (M,3), got { voxel_coords . shape } \" ) if voxel_features . ndim != 2 : raise ValueError ( f \"voxel_features must be (M,C), got { voxel_features . shape } \" ) if voxel_coords . shape [ 0 ] != voxel_features . shape [ 0 ]: raise ValueError ( \"voxel_coords and voxel_features must have same length\" ) # \u63a8\u7406\u9636\u6bb5\u6216\u4e0d\u4e22\u5f03\uff1a\u4e5f\u5fc5\u987b\u8fd4\u56de clone\uff08custom_op \u7981\u6b62 alias\uff09 if ( not training ) or discard_rate <= 0.0 : return voxel_coords . clone (), voxel_features . clone () # \u6781\u7aef\u60c5\u51b5\uff1a\u5168\u4e22\u5f03 if discard_rate >= 1.0 : empty_coords = voxel_coords [: 0 ] . clone () empty_feats = voxel_features [: 0 ] . clone () return empty_coords , empty_feats keep_prob = 1.0 - float ( discard_rate ) rand = torch . rand (( voxel_coords . shape [ 0 ],), device = voxel_coords . device , dtype = torch . float32 ) keep_mask = rand < keep_prob coords_kept = voxel_coords [ keep_mask ] . clone () feats_kept = voxel_features [ keep_mask ] . clone () return coords_kept , feats_kept","title":"stvd_layer"},{"location":"VirConvStage/#projection","text":"","title":"projection"},{"location":"VirConvStage/#VirConvBlockStage.operator.projection.projection","text":"\u5c06\u4f53\u7d20\u5750\u6807\u6295\u5f71\u5230\u56fe\u50cf\u5e73\u9762\uff0c\u751f\u6210\u5bf9\u5e94\u7684 2D \u50cf\u7d20\u5750\u6807\u3002 Parameters: voxel_coords ( Tensor ) \u2013 (M, 3) \u4f53\u7d20\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_size ( Tensor ) \u2013 (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range ( Tensor ) \u2013 (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 proj_matrix ( Tensor ) \u2013 (3, 4) \u76f8\u673a\u6295\u5f71\u77e9\u9635\uff08K[R|t]\uff09\u3002 Returns: pixel_coords ( Tensor ) \u2013 (M, 2) \u6bcf\u4e2a\u4f53\u7d20\u4e2d\u5fc3\u5bf9\u5e94\u7684\u56fe\u50cf\u5e73\u9762\u50cf\u7d20\u5750\u6807 (u, v)\u3002 Source code in VirConvBlockStage\\operator\\projection.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @torch . library . custom_op ( \"virconv::projection\" , mutates_args = []) def projection ( voxel_coords : torch . Tensor , voxel_size : torch . Tensor , point_cloud_range : torch . Tensor , proj_matrix : torch . Tensor ) -> torch . Tensor : \"\"\" \u5c06\u4f53\u7d20\u5750\u6807\u6295\u5f71\u5230\u56fe\u50cf\u5e73\u9762\uff0c\u751f\u6210\u5bf9\u5e94\u7684 2D \u50cf\u7d20\u5750\u6807\u3002 Args: voxel_coords: (M, 3) \u4f53\u7d20\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_size: (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range: (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 proj_matrix: (3, 4) \u76f8\u673a\u6295\u5f71\u77e9\u9635\uff08K[R|t]\uff09\u3002 Returns: pixel_coords: (M, 2) \u6bcf\u4e2a\u4f53\u7d20\u4e2d\u5fc3\u5bf9\u5e94\u7684\u56fe\u50cf\u5e73\u9762\u50cf\u7d20\u5750\u6807 (u, v)\u3002 \"\"\" if voxel_coords . ndim != 2 or voxel_coords . shape [ 1 ] != 3 : raise ValueError ( f \"voxel_coords must be (M,3), got { voxel_coords . shape } \" ) device = voxel_coords . device # \u7edf\u4e00 device / dtype voxel_size = voxel_size . to ( device = device , dtype = torch . float32 ) point_cloud_range = point_cloud_range . to ( device = device , dtype = torch . float32 ) proj_matrix = proj_matrix . to ( device = device , dtype = torch . float32 ) pc_min = point_cloud_range [: 3 ] centers = ( voxel_coords . to ( torch . float32 ) + 0.5 ) * voxel_size + pc_min # (M,3) ones = torch . ones (( centers . shape [ 0 ], 1 ), device = device , dtype = torch . float32 ) centers_homo = torch . cat ([ centers , ones ], dim = 1 ) # (M,4) pixels_homo = centers_homo @ proj_matrix . t () # (M,3) pixels = pixels_homo [:, : 2 ] / pixels_homo [:, 2 : 3 ] . clamp_min ( 1e-6 ) return pixels . clone () # custom_op \u8f93\u51fa\u4e0d\u5141\u8bb8 alias","title":"projection"},{"location":"VirConvStage/#nrconv3d","text":"","title":"NRConv3D"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv3D.NRConv3D","text":"Bases: Module NRConv 3D \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u6838\u5fc3\u53ef\u5b66\u4e60\u7b97\u5b50\u4e4b\u4e00\uff09\u3002 \u8be5\u6a21\u5757\u5728 \u4e09\u7ef4\u4f53\u7d20\u7a7a\u95f4 \u4e2d\u5bf9\u7a00\u758f\u4f53\u7d20\u7279\u5f81\u6267\u884c 3D \u5b50\u6d41\u5f62\u5377\u79ef\uff08Submanifold Sparse Convolution\uff09\uff0c \u7528\u4e8e\u5efa\u6a21\u4f53\u7d20\u5c40\u90e8\u90bb\u57df\u7684\u51e0\u4f55\u7ed3\u6784\u4e0e\u8bed\u4e49\u4fe1\u606f\u3002\u5176\u76ee\u6807\u4e0d\u662f\u6539\u53d8\u4f53\u7d20\u7684\u7a7a\u95f4\u5206\u5e03\uff0c \u800c\u662f\u5728 \u4fdd\u6301\u4f53\u7d20\u5750\u6807\u4e0d\u53d8 \u7684\u524d\u63d0\u4e0b\uff0c\u589e\u5f3a\u6bcf\u4e2a\u4f53\u7d20\u7684 3D \u8868\u8fbe\u80fd\u529b\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0cNRConv 3D \u662f \u8d28\u91cf\u5efa\u6a21\uff08Stage C\uff09 \u7684\u7b2c\u4e00\u6b65\uff0c \u4e3a\u540e\u7eed\u7684 2D \u6295\u5f71\u4e0e 2D NRConv \u63d0\u4f9b\u53ef\u9760\u7684\u4e09\u7ef4\u7279\u5f81\u57fa\u7840\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e \u53ef\u5b66\u4e60\u7b97\u5b50 \uff0c\u5176\u5377\u79ef\u6838\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u8fdb\u884c\u66f4\u65b0\u3002","title":"NRConv3D"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv3D.NRConv3D--_1","text":"Submanifold Sparse Conv3D \u5728\u4f53\u7d20 3D \u90bb\u57df\u5185\u8fdb\u884c\u5377\u79ef\u8ba1\u7b97 \u4e0d\u5f15\u5165\u65b0\u7684\u4f53\u7d20\uff0c\u4e0d\u6539\u53d8\u4f53\u7d20\u5750\u6807\u96c6\u5408 BatchNorm1d \u5bf9\u4f53\u7d20\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316\uff0c\u52a0\u901f\u6536\u655b ReLU \u6fc0\u6d3b \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b","title":"\u7ed3\u6784\u8bf4\u660e"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv3D.NRConv3D--_2","text":"Args: voxel_features (torch.Tensor): \u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_in) - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6","title":"\u8f93\u5165"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv3D.NRConv3D--_3","text":"Returns: torch.Tensor: \u66f4\u65b0\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_out)","title":"\u8f93\u51fa"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv3D.NRConv3D--_4","text":"\u5efa\u6a21\u4f53\u7d20\u5728 3D \u7a7a\u95f4\u4e2d\u7684\u5c40\u90e8\u51e0\u4f55\u5173\u7cfb \u6291\u5236\u7531\u865a\u62df\u70b9\u5f15\u5165\u7684\u566a\u58f0\u7279\u5f81 \u4e3a\u540e\u7eed\u7684 2D \u6295\u5f71\u4e0e\u8de8\u6a21\u6001\u878d\u5408\u63d0\u4f9b\u9ad8\u8d28\u91cf 3D \u8868\u5f81 \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u7ec4\u6210\u90e8\u5206 Source code in VirConvBlockStage\\network\\NRConv3D.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class NRConv3D ( nn . Module ): \"\"\" NRConv 3D \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u6838\u5fc3\u53ef\u5b66\u4e60\u7b97\u5b50\u4e4b\u4e00\uff09\u3002 \u8be5\u6a21\u5757\u5728 **\u4e09\u7ef4\u4f53\u7d20\u7a7a\u95f4** \u4e2d\u5bf9\u7a00\u758f\u4f53\u7d20\u7279\u5f81\u6267\u884c 3D \u5b50\u6d41\u5f62\u5377\u79ef\uff08Submanifold Sparse Convolution\uff09\uff0c \u7528\u4e8e\u5efa\u6a21\u4f53\u7d20\u5c40\u90e8\u90bb\u57df\u7684\u51e0\u4f55\u7ed3\u6784\u4e0e\u8bed\u4e49\u4fe1\u606f\u3002\u5176\u76ee\u6807\u4e0d\u662f\u6539\u53d8\u4f53\u7d20\u7684\u7a7a\u95f4\u5206\u5e03\uff0c \u800c\u662f\u5728 **\u4fdd\u6301\u4f53\u7d20\u5750\u6807\u4e0d\u53d8** \u7684\u524d\u63d0\u4e0b\uff0c\u589e\u5f3a\u6bcf\u4e2a\u4f53\u7d20\u7684 3D \u8868\u8fbe\u80fd\u529b\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0cNRConv 3D \u662f **\u8d28\u91cf\u5efa\u6a21\uff08Stage C\uff09** \u7684\u7b2c\u4e00\u6b65\uff0c \u4e3a\u540e\u7eed\u7684 2D \u6295\u5f71\u4e0e 2D NRConv \u63d0\u4f9b\u53ef\u9760\u7684\u4e09\u7ef4\u7279\u5f81\u57fa\u7840\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e **\u53ef\u5b66\u4e60\u7b97\u5b50**\uff0c\u5176\u5377\u79ef\u6838\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u8fdb\u884c\u66f4\u65b0\u3002 --- ### \u7ed3\u6784\u8bf4\u660e 1. **Submanifold Sparse Conv3D** - \u5728\u4f53\u7d20 3D \u90bb\u57df\u5185\u8fdb\u884c\u5377\u79ef\u8ba1\u7b97 - \u4e0d\u5f15\u5165\u65b0\u7684\u4f53\u7d20\uff0c\u4e0d\u6539\u53d8\u4f53\u7d20\u5750\u6807\u96c6\u5408 2. **BatchNorm1d** - \u5bf9\u4f53\u7d20\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316\uff0c\u52a0\u901f\u6536\u655b 3. **ReLU \u6fc0\u6d3b** - \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b --- ### \u8f93\u5165 Args: voxel_features (torch.Tensor): \u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_in)** - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6 --- ### \u8f93\u51fa Returns: torch.Tensor: \u66f4\u65b0\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_out)** --- ### \u6a21\u5757\u7528\u9014 - \u5efa\u6a21\u4f53\u7d20\u5728 3D \u7a7a\u95f4\u4e2d\u7684\u5c40\u90e8\u51e0\u4f55\u5173\u7cfb - \u6291\u5236\u7531\u865a\u62df\u70b9\u5f15\u5165\u7684\u566a\u58f0\u7279\u5f81 - \u4e3a\u540e\u7eed\u7684 2D \u6295\u5f71\u4e0e\u8de8\u6a21\u6001\u878d\u5408\u63d0\u4f9b\u9ad8\u8d28\u91cf 3D \u8868\u5f81 - \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u7ec4\u6210\u90e8\u5206 \"\"\" def __init__ ( self , in_channels : int , out_channels : int ): super () . __init__ () # \u4f7f\u7528\u666e\u901a Linear \u8fd1\u4f3c SubMConv3D\uff08\u7b97\u5b50\u7ea7\u62bd\u8c61\u7248\u672c\uff09 # \u82e5\u63a5\u5165 spconv\uff0c\u53ef\u5728\u6b64\u5904\u66ff\u6362\u4e3a SubMConv3d self . linear = nn . Linear ( in_channels , out_channels , bias = False ) # 3D \u5377\u79ef\u7b49\u4ef7\u6620\u5c04 self . bn = nn . BatchNorm1d ( out_channels ) # \u6279\u5f52\u4e00\u5316 self . relu = nn . ReLU ( inplace = True ) # \u975e\u7ebf\u6027\u6fc0\u6d3b def forward ( self , voxel_features : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" x = self . linear ( voxel_features ) # \u7ebf\u6027\u6620\u5c04\uff08\u8fd1\u4f3c 3D SubMConv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x","title":"\u6a21\u5757\u7528\u9014"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv3D.NRConv3D.forward","text":"\u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Parameters: voxel_features ( Tensor ) \u2013 \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: Tensor \u2013 torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) Source code in VirConvBlockStage\\network\\NRConv3D.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def forward ( self , voxel_features : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" x = self . linear ( voxel_features ) # \u7ebf\u6027\u6620\u5c04\uff08\u8fd1\u4f3c 3D SubMConv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x","title":"forward"},{"location":"VirConvStage/#nrconv2d","text":"","title":"NRConv2D"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv2D.NRConv2D","text":"Bases: Module NRConv 2D \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u6838\u5fc3\u53ef\u5b66\u4e60\u7b97\u5b50\u4e4b\u4e00\uff09\u3002 \u8be5\u6a21\u5757\u5728 \u56fe\u50cf\u5e73\u9762\uff082D \u7a7a\u95f4\uff09 \u4e0a\u5bf9\u7531\u4f53\u7d20\u6295\u5f71\u5f97\u5230\u7684\u7279\u5f81\u6267\u884c 2D \u5377\u79ef\u5efa\u6a21\uff0c \u7528\u4e8e\u6355\u83b7\u4f53\u7d20\u5728\u56fe\u50cf\u89c6\u89d2\u4e0b\u7684\u5c40\u90e8\u4e0a\u4e0b\u6587\u4e0e\u8fb9\u754c\u4fe1\u606f\uff0c\u4ece\u800c\u8f85\u52a9\u5224\u65ad\u4f53\u7d20\u7279\u5f81\u7684\u53ef\u9760\u6027\u3002 \u4e0e NRConv 3D \u4e0d\u540c\uff0c\u672c\u6a21\u5757\u5173\u6ce8\u7684\u662f \u56fe\u50cf\u51e0\u4f55\u7ed3\u6784\u4e0e\u6df1\u5ea6\u4e0d\u8fde\u7eed\u6a21\u5f0f \u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0cNRConv 2D \u4f4d\u4e8e Projection \u4e4b\u540e\uff0c\u4e0e NRConv 3D \u5f62\u6210\u4e92\u8865\uff0c \u4e24\u8005\u7684\u8f93\u51fa\u5c06\u5728\u540e\u7eed Fusion \u7b97\u5b50\u4e2d\u8fdb\u884c\u878d\u5408\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e \u53ef\u5b66\u4e60\u7b97\u5b50 \uff0c\u5176\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u8fdb\u884c\u66f4\u65b0\u3002","title":"NRConv2D"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv2D.NRConv2D--_1","text":"2D Convolution\uff08kernel=3, padding=1\uff09 \u5728\u56fe\u50cf\u5e73\u9762\u90bb\u57df\u5185\u5efa\u6a21\u5c40\u90e8\u4e0a\u4e0b\u6587\u4fe1\u606f BatchNorm1d \u5bf9\u4f53\u7d20\u7ea7\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316 ReLU \u6fc0\u6d3b \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b","title":"\u7ed3\u6784\u8bf4\u660e"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv2D.NRConv2D--_2","text":"Args: voxel_features (torch.Tensor): \u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_in) - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6 pixel_coords (torch.Tensor): \u6295\u5f71\u5f97\u5230\u7684 2D \u50cf\u7d20\u5750\u6807\uff0cshape \u4e3a (M, 2) - \u6bcf\u4e2a\u4f53\u7d20\u5728\u56fe\u50cf\u5e73\u9762\u4e2d\u7684\u4f4d\u7f6e (u, v)","title":"\u8f93\u5165"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv2D.NRConv2D--_3","text":"Returns: torch.Tensor: \u66f4\u65b0\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_out)","title":"\u8f93\u51fa"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv2D.NRConv2D--_4","text":"\u4ece\u56fe\u50cf\u89c6\u89d2\u5efa\u6a21\u4f53\u7d20\u7684\u5c40\u90e8\u4e0a\u4e0b\u6587\u4fe1\u606f \u611f\u77e5\u6df1\u5ea6\u8865\u5168\u6216\u865a\u62df\u70b9\u5e26\u6765\u7684\u8fb9\u754c\u4e0e\u566a\u58f0\u6a21\u5f0f \u4e0e NRConv 3D \u5f62\u6210\u4e92\u8865\u7684\u8de8\u7a7a\u95f4\u7279\u5f81\u8868\u793a \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u7ec4\u6210\u90e8\u5206 Source code in VirConvBlockStage\\network\\NRConv2D.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class NRConv2D ( nn . Module ): \"\"\" NRConv 2D \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u6838\u5fc3\u53ef\u5b66\u4e60\u7b97\u5b50\u4e4b\u4e00\uff09\u3002 \u8be5\u6a21\u5757\u5728 **\u56fe\u50cf\u5e73\u9762\uff082D \u7a7a\u95f4\uff09** \u4e0a\u5bf9\u7531\u4f53\u7d20\u6295\u5f71\u5f97\u5230\u7684\u7279\u5f81\u6267\u884c 2D \u5377\u79ef\u5efa\u6a21\uff0c \u7528\u4e8e\u6355\u83b7\u4f53\u7d20\u5728\u56fe\u50cf\u89c6\u89d2\u4e0b\u7684\u5c40\u90e8\u4e0a\u4e0b\u6587\u4e0e\u8fb9\u754c\u4fe1\u606f\uff0c\u4ece\u800c\u8f85\u52a9\u5224\u65ad\u4f53\u7d20\u7279\u5f81\u7684\u53ef\u9760\u6027\u3002 \u4e0e NRConv 3D \u4e0d\u540c\uff0c\u672c\u6a21\u5757\u5173\u6ce8\u7684\u662f **\u56fe\u50cf\u51e0\u4f55\u7ed3\u6784\u4e0e\u6df1\u5ea6\u4e0d\u8fde\u7eed\u6a21\u5f0f**\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0cNRConv 2D \u4f4d\u4e8e Projection \u4e4b\u540e\uff0c\u4e0e NRConv 3D \u5f62\u6210\u4e92\u8865\uff0c \u4e24\u8005\u7684\u8f93\u51fa\u5c06\u5728\u540e\u7eed Fusion \u7b97\u5b50\u4e2d\u8fdb\u884c\u878d\u5408\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e **\u53ef\u5b66\u4e60\u7b97\u5b50**\uff0c\u5176\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u8fdb\u884c\u66f4\u65b0\u3002 --- ### \u7ed3\u6784\u8bf4\u660e 1. **2D Convolution\uff08kernel=3, padding=1\uff09** - \u5728\u56fe\u50cf\u5e73\u9762\u90bb\u57df\u5185\u5efa\u6a21\u5c40\u90e8\u4e0a\u4e0b\u6587\u4fe1\u606f 2. **BatchNorm1d** - \u5bf9\u4f53\u7d20\u7ea7\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316 3. **ReLU \u6fc0\u6d3b** - \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b --- ### \u8f93\u5165 Args: voxel_features (torch.Tensor): \u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_in)** - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6 pixel_coords (torch.Tensor): \u6295\u5f71\u5f97\u5230\u7684 2D \u50cf\u7d20\u5750\u6807\uff0cshape \u4e3a **(M, 2)** - \u6bcf\u4e2a\u4f53\u7d20\u5728\u56fe\u50cf\u5e73\u9762\u4e2d\u7684\u4f4d\u7f6e (u, v) --- ### \u8f93\u51fa Returns: torch.Tensor: \u66f4\u65b0\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_out)** --- ### \u6a21\u5757\u7528\u9014 - \u4ece\u56fe\u50cf\u89c6\u89d2\u5efa\u6a21\u4f53\u7d20\u7684\u5c40\u90e8\u4e0a\u4e0b\u6587\u4fe1\u606f - \u611f\u77e5\u6df1\u5ea6\u8865\u5168\u6216\u865a\u62df\u70b9\u5e26\u6765\u7684\u8fb9\u754c\u4e0e\u566a\u58f0\u6a21\u5f0f - \u4e0e NRConv 3D \u5f62\u6210\u4e92\u8865\u7684\u8de8\u7a7a\u95f4\u7279\u5f81\u8868\u793a - \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u7ec4\u6210\u90e8\u5206 \"\"\" def __init__ ( self , in_channels : int , out_channels : int ): super () . __init__ () # \u4f7f\u7528 Linear \u8fd1\u4f3c 2D \u5377\u79ef\uff08\u7b97\u5b50\u7ea7\u62bd\u8c61\u7248\u672c\uff09 # \u82e5\u6784\u5efa\u771f\u5b9e 2D feature map\uff0c\u53ef\u66ff\u6362\u4e3a nn.Conv2d self . linear = nn . Linear ( in_channels , out_channels , bias = False ) # 2D \u5377\u79ef\u7b49\u4ef7\u6620\u5c04 self . bn = nn . BatchNorm1d ( out_channels ) # \u6279\u5f52\u4e00\u5316 self . relu = nn . ReLU ( inplace = True ) # \u975e\u7ebf\u6027\u6fc0\u6d3b def forward ( self , voxel_features : torch . Tensor , pixel_coords : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) pixel_coords (torch.Tensor): \u6295\u5f71\u540e\u7684 2D \u50cf\u7d20\u5750\u6807\uff0cshape \u4e3a (M, 2) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" # \u5f53\u524d\u7b97\u5b50\u7ea7\u62bd\u8c61\u4e2d\uff0cpixel_coords \u4ec5\u4f5c\u4e3a\u51e0\u4f55\u5173\u8054\u8f93\u5165\uff0c\u4e0d\u76f4\u63a5\u53c2\u4e0e\u8ba1\u7b97 x = self . linear ( voxel_features ) # \u7279\u5f81\u6620\u5c04\uff08\u8fd1\u4f3c 2D Conv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x","title":"\u6a21\u5757\u7528\u9014"},{"location":"VirConvStage/#VirConvBlockStage.network.NRConv2D.NRConv2D.forward","text":"\u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Parameters: voxel_features ( Tensor ) \u2013 \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) pixel_coords ( Tensor ) \u2013 \u6295\u5f71\u540e\u7684 2D \u50cf\u7d20\u5750\u6807\uff0cshape \u4e3a (M, 2) Returns: Tensor \u2013 torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) Source code in VirConvBlockStage\\network\\NRConv2D.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def forward ( self , voxel_features : torch . Tensor , pixel_coords : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) pixel_coords (torch.Tensor): \u6295\u5f71\u540e\u7684 2D \u50cf\u7d20\u5750\u6807\uff0cshape \u4e3a (M, 2) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" # \u5f53\u524d\u7b97\u5b50\u7ea7\u62bd\u8c61\u4e2d\uff0cpixel_coords \u4ec5\u4f5c\u4e3a\u51e0\u4f55\u5173\u8054\u8f93\u5165\uff0c\u4e0d\u76f4\u63a5\u53c2\u4e0e\u8ba1\u7b97 x = self . linear ( voxel_features ) # \u7279\u5f81\u6620\u5c04\uff08\u8fd1\u4f3c 2D Conv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x","title":"forward"},{"location":"VirConvStage/#sparseconv3d","text":"","title":"SparseConv3D"},{"location":"VirConvStage/#VirConvBlockStage.network.SparseConv3D.SparseConv3D","text":"Bases: Module 3D SpConv \u6a21\u5757\uff08VirConv Backbone \u9636\u6bb5 D \u7684\u6838\u5fc3\u7ed3\u6784\u7b97\u5b50\uff09\u3002 \u8be5\u6a21\u5757\u5728 \u4e09\u7ef4\u4f53\u7d20\u7a7a\u95f4 \u4e2d\u5bf9\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\u6267\u884c\u7a00\u758f 3D \u5377\u79ef\uff0c \u7528\u4e8e\u8fdb\u884c \u7a7a\u95f4\u7ed3\u6784\u5efa\u6a21\u4e0e\u5c3a\u5ea6\u53d8\u6362 \u3002\u4e0e NRConv \u4e0d\u540c\uff0c \u672c\u6a21\u5757\u5141\u8bb8\u901a\u8fc7 stride \u5b9e\u73b0 \u4e0b\u91c7\u6837 \uff0c\u4ece\u800c\u6269\u5927\u611f\u53d7\u91ce\u5e76\u9010\u6b65\u6784\u5efa \u591a\u5c3a\u5ea6\u4e09\u7ef4\u7279\u5f81\u8868\u793a\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0c3D SpConv \u6807\u5fd7\u7740\u4ece \u878d\u5408\u5efa\u6a21\uff08Stage C\uff09 \u8fdb\u5165 Backbone \u7279\u5f81\u62bd\u8c61\uff08Stage D\uff09 \uff0c\u5176\u8f93\u51fa\u5c06\u4f5c\u4e3a\u4e0b\u4e00\u5c42 VirConv Block \u6216\u540e\u7eed\u7f51\u7edc\u6a21\u5757\u7684\u8f93\u5165\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e \u53ef\u5b66\u4e60\u7b97\u5b50 \uff0c\u5176\u5377\u79ef\u6838\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u66f4\u65b0\u3002","title":"SparseConv3D"},{"location":"VirConvStage/#VirConvBlockStage.network.SparseConv3D.SparseConv3D--_1","text":"3D Sparse Convolution\uff08\u53ef\u5e26 stride\uff09 \u5728\u4f53\u7d20 3D \u90bb\u57df\u5185\u8fdb\u884c\u5377\u79ef\u8ba1\u7b97 \u53ef\u901a\u8fc7 stride > 1 \u5b9e\u73b0\u4f53\u7d20\u4e0b\u91c7\u6837 BatchNorm1d \u5bf9\u4f53\u7d20\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316\uff0c\u7a33\u5b9a\u8bad\u7ec3\u8fc7\u7a0b ReLU \u6fc0\u6d3b \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b","title":"\u7ed3\u6784\u8bf4\u660e"},{"location":"VirConvStage/#VirConvBlockStage.network.SparseConv3D.SparseConv3D--_2","text":"Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_in) - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u7279\u5f81\u7ef4\u5ea6","title":"\u8f93\u5165"},{"location":"VirConvStage/#VirConvBlockStage.network.SparseConv3D.SparseConv3D--_3","text":"Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M', C_out) - M'\uff1a\u4e0b\u91c7\u6837\u540e\u4f53\u7d20\u6570\u91cf\uff08\u53ef\u80fd\u5c0f\u4e8e M\uff09 - C_out\uff1a\u8f93\u51fa\u7279\u5f81\u7ef4\u5ea6","title":"\u8f93\u51fa"},{"location":"VirConvStage/#VirConvBlockStage.network.SparseConv3D.SparseConv3D--_4","text":"\u6784\u5efa\u591a\u5c3a\u5ea6\u4e09\u7ef4\u7279\u5f81\u8868\u793a \u6269\u5927\u4f53\u7d20\u7279\u5f81\u7684\u7a7a\u95f4\u611f\u53d7\u91ce \u4e3a\u540e\u7eed\u68c0\u6d4b\u6216\u66f4\u9ad8\u5c42 Backbone \u63d0\u4f9b\u62bd\u8c61\u8bed\u4e49\u7279\u5f81 \u5c5e\u4e8e VirConv \u7684 Stage D\uff083D SpConv Backbone\uff09 Source code in VirConvBlockStage\\network\\SparseConv3D.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class SparseConv3D ( nn . Module ): \"\"\" 3D SpConv \u6a21\u5757\uff08VirConv Backbone \u9636\u6bb5 D \u7684\u6838\u5fc3\u7ed3\u6784\u7b97\u5b50\uff09\u3002 \u8be5\u6a21\u5757\u5728 **\u4e09\u7ef4\u4f53\u7d20\u7a7a\u95f4** \u4e2d\u5bf9\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\u6267\u884c\u7a00\u758f 3D \u5377\u79ef\uff0c \u7528\u4e8e\u8fdb\u884c **\u7a7a\u95f4\u7ed3\u6784\u5efa\u6a21\u4e0e\u5c3a\u5ea6\u53d8\u6362**\u3002\u4e0e NRConv \u4e0d\u540c\uff0c \u672c\u6a21\u5757\u5141\u8bb8\u901a\u8fc7 stride \u5b9e\u73b0 **\u4e0b\u91c7\u6837**\uff0c\u4ece\u800c\u6269\u5927\u611f\u53d7\u91ce\u5e76\u9010\u6b65\u6784\u5efa \u591a\u5c3a\u5ea6\u4e09\u7ef4\u7279\u5f81\u8868\u793a\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0c3D SpConv \u6807\u5fd7\u7740\u4ece **\u878d\u5408\u5efa\u6a21\uff08Stage C\uff09** \u8fdb\u5165 **Backbone \u7279\u5f81\u62bd\u8c61\uff08Stage D\uff09**\uff0c\u5176\u8f93\u51fa\u5c06\u4f5c\u4e3a\u4e0b\u4e00\u5c42 VirConv Block \u6216\u540e\u7eed\u7f51\u7edc\u6a21\u5757\u7684\u8f93\u5165\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e **\u53ef\u5b66\u4e60\u7b97\u5b50**\uff0c\u5176\u5377\u79ef\u6838\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u901a\u8fc7\u53cd\u5411\u4f20\u64ad\u66f4\u65b0\u3002 --- ### \u7ed3\u6784\u8bf4\u660e 1. **3D Sparse Convolution\uff08\u53ef\u5e26 stride\uff09** - \u5728\u4f53\u7d20 3D \u90bb\u57df\u5185\u8fdb\u884c\u5377\u79ef\u8ba1\u7b97 - \u53ef\u901a\u8fc7 stride > 1 \u5b9e\u73b0\u4f53\u7d20\u4e0b\u91c7\u6837 2. **BatchNorm1d** - \u5bf9\u4f53\u7d20\u7279\u5f81\u8fdb\u884c\u5f52\u4e00\u5316\uff0c\u7a33\u5b9a\u8bad\u7ec3\u8fc7\u7a0b 3. **ReLU \u6fc0\u6d3b** - \u63d0\u4f9b\u975e\u7ebf\u6027\u8868\u8fbe\u80fd\u529b --- ### \u8f93\u5165 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_in)** - M\uff1a\u975e\u7a7a\u4f53\u7d20\u6570\u91cf - C_in\uff1a\u8f93\u5165\u7279\u5f81\u7ef4\u5ea6 --- ### \u8f93\u51fa Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M', C_out)** - M'\uff1a\u4e0b\u91c7\u6837\u540e\u4f53\u7d20\u6570\u91cf\uff08\u53ef\u80fd\u5c0f\u4e8e M\uff09 - C_out\uff1a\u8f93\u51fa\u7279\u5f81\u7ef4\u5ea6 --- ### \u6a21\u5757\u7528\u9014 - \u6784\u5efa\u591a\u5c3a\u5ea6\u4e09\u7ef4\u7279\u5f81\u8868\u793a - \u6269\u5927\u4f53\u7d20\u7279\u5f81\u7684\u7a7a\u95f4\u611f\u53d7\u91ce - \u4e3a\u540e\u7eed\u68c0\u6d4b\u6216\u66f4\u9ad8\u5c42 Backbone \u63d0\u4f9b\u62bd\u8c61\u8bed\u4e49\u7279\u5f81 - \u5c5e\u4e8e VirConv \u7684 Stage D\uff083D SpConv Backbone\uff09 \"\"\" def __init__ ( self , in_channels : int , out_channels : int , stride : int = 1 ): super () . __init__ () # \u4f7f\u7528 Linear \u8fd1\u4f3c 3D Sparse Convolution\uff08\u7b97\u5b50\u7ea7\u62bd\u8c61\u7248\u672c\uff09 # \u82e5\u63a5\u5165 spconv\uff0c\u53ef\u5728\u6b64\u5904\u66ff\u6362\u4e3a SparseConv3d / SubMConv3d self . linear = nn . Linear ( in_channels , out_channels , bias = False ) # \u7279\u5f81\u6620\u5c04 self . bn = nn . BatchNorm1d ( out_channels ) # \u6279\u5f52\u4e00\u5316 self . relu = nn . ReLU ( inplace = True ) # \u975e\u7ebf\u6027\u6fc0\u6d3b self . stride = stride # \u4e0b\u91c7\u6837\u6b65\u957f\uff08\u8bed\u4e49\u5360\u4f4d\uff09 def forward ( self , voxel_features : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M', C_out) \"\"\" # \u5f53\u524d\u7b97\u5b50\u7ea7\u62bd\u8c61\u4e2d\uff0cstride \u4e0d\u663e\u5f0f\u6539\u53d8\u5750\u6807\uff0c\u4ec5\u8868\u8fbe\u8bed\u4e49 x = self . linear ( voxel_features ) # \u7279\u5f81\u6620\u5c04\uff08\u8fd1\u4f3c 3D SpConv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x","title":"\u6a21\u5757\u7528\u9014"},{"location":"VirConvStage/#VirConvBlockStage.network.SparseConv3D.SparseConv3D.forward","text":"\u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Parameters: voxel_features ( Tensor ) \u2013 \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: Tensor \u2013 torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M', C_out) Source code in VirConvBlockStage\\network\\SparseConv3D.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def forward ( self , voxel_features : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: voxel_features (torch.Tensor): \u8f93\u5165\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_in) Returns: torch.Tensor: \u8f93\u51fa\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M', C_out) \"\"\" # \u5f53\u524d\u7b97\u5b50\u7ea7\u62bd\u8c61\u4e2d\uff0cstride \u4e0d\u663e\u5f0f\u6539\u53d8\u5750\u6807\uff0c\u4ec5\u8868\u8fbe\u8bed\u4e49 x = self . linear ( voxel_features ) # \u7279\u5f81\u6620\u5c04\uff08\u8fd1\u4f3c 3D SpConv\uff09 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x","title":"forward"},{"location":"VirConvStage/#featurefusion","text":"","title":"FeatureFusion"},{"location":"VirConvStage/#VirConvBlockStage.network.FeatureFusion.FeatureFusion","text":"Bases: Module Feature Fusion \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u878d\u5408\u7b97\u5b50\uff09\u3002 \u8be5\u6a21\u5757\u7528\u4e8e\u878d\u5408 NRConv 3D \u4e0e NRConv 2D \u4e24\u6761\u5206\u652f\u8f93\u51fa\u7684\u4f53\u7d20\u7279\u5f81\uff0c \u5c06\u6765\u81ea\u4e09\u7ef4\u7a7a\u95f4\u4e0e\u56fe\u50cf\u5e73\u9762\u7684\u4e92\u8865\u4fe1\u606f\u6574\u5408\u4e3a\u7edf\u4e00\u7684\u4f53\u7d20\u7ea7\u8868\u793a\u3002 \u5176\u6838\u5fc3\u601d\u60f3\u662f\u5728 \u4e0d\u6539\u53d8\u4f53\u7d20\u7a7a\u95f4\u7ed3\u6784 \u7684\u524d\u63d0\u4e0b\uff0c\u5bf9\u540c\u4e00\u4f53\u7d20\u7684\u591a\u6e90\u7279\u5f81 \u8fdb\u884c\u901a\u9053\u7ea7\u878d\u5408\uff0c\u4ece\u800c\u83b7\u5f97\u66f4\u5177\u5224\u522b\u6027\u7684\u878d\u5408\u7279\u5f81\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0c\u672c\u7b97\u5b50\u4f4d\u4e8e NRConv (3D / 2D) \u4e4b\u540e\uff0c \u662f\u5b8c\u6210 \u8de8\u7a7a\u95f4\u4fe1\u606f\u6574\u5408 \u7684\u5173\u952e\u4e00\u6b65\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e \u53ef\u5b66\u4e60\u7b97\u5b50 \uff0c\u5176\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u6839\u636e\u76d1\u7763\u4fe1\u53f7\u8fdb\u884c\u66f4\u65b0\u3002","title":"FeatureFusion"},{"location":"VirConvStage/#VirConvBlockStage.network.FeatureFusion.FeatureFusion--_1","text":"\u7279\u5f81\u62fc\u63a5\uff08Concat\uff09 \u5c06 3D \u4e0e 2D \u7279\u5f81\u5728\u901a\u9053\u7ef4\u5ea6\u8fdb\u884c\u62fc\u63a5 Linear \u6620\u5c04\uff08\u7b49\u4ef7\u4e8e 1\u00d71 Conv\uff09 \u5bf9\u62fc\u63a5\u540e\u7684\u7279\u5f81\u8fdb\u884c\u901a\u9053\u538b\u7f29\u4e0e\u91cd\u6620\u5c04 BatchNorm1d \u7a33\u5b9a\u7279\u5f81\u5206\u5e03\uff0c\u52a0\u901f\u8bad\u7ec3\u6536\u655b ReLU \u6fc0\u6d3b \u5f15\u5165\u975e\u7ebf\u6027\uff0c\u589e\u5f3a\u7279\u5f81\u8868\u8fbe\u80fd\u529b","title":"\u7ed3\u6784\u8bf4\u660e"},{"location":"VirConvStage/#VirConvBlockStage.network.FeatureFusion.FeatureFusion--_2","text":"Args: feat_3d (torch.Tensor): \u6765\u81ea NRConv 3D \u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_3d) feat_2d (torch.Tensor): \u6765\u81ea NRConv 2D \u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_2d)","title":"\u8f93\u5165"},{"location":"VirConvStage/#VirConvBlockStage.network.FeatureFusion.FeatureFusion--_3","text":"Returns: torch.Tensor: \u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a (M, C_out)","title":"\u8f93\u51fa"},{"location":"VirConvStage/#VirConvBlockStage.network.FeatureFusion.FeatureFusion--_4","text":"\u878d\u5408\u4e09\u7ef4\u51e0\u4f55\u4fe1\u606f\u4e0e\u4e8c\u7ef4\u56fe\u50cf\u7ed3\u6784\u4fe1\u606f \u63d0\u5347\u4f53\u7d20\u7279\u5f81\u5bf9\u865a\u62df\u70b9\u566a\u58f0\u7684\u9c81\u68d2\u6027 \u4e3a\u540e\u7eed 3D SpConv Backbone \u63d0\u4f9b\u9ad8\u8d28\u91cf\u8f93\u5165\u7279\u5f81 \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u672b\u7aef\u878d\u5408\u7b97\u5b50 Source code in VirConvBlockStage\\network\\FeatureFusion.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class FeatureFusion ( nn . Module ): \"\"\" Feature Fusion \u6a21\u5757\uff08VirConv \u9636\u6bb5 C \u7684\u878d\u5408\u7b97\u5b50\uff09\u3002 \u8be5\u6a21\u5757\u7528\u4e8e\u878d\u5408 **NRConv 3D** \u4e0e **NRConv 2D** \u4e24\u6761\u5206\u652f\u8f93\u51fa\u7684\u4f53\u7d20\u7279\u5f81\uff0c \u5c06\u6765\u81ea\u4e09\u7ef4\u7a7a\u95f4\u4e0e\u56fe\u50cf\u5e73\u9762\u7684\u4e92\u8865\u4fe1\u606f\u6574\u5408\u4e3a\u7edf\u4e00\u7684\u4f53\u7d20\u7ea7\u8868\u793a\u3002 \u5176\u6838\u5fc3\u601d\u60f3\u662f\u5728 **\u4e0d\u6539\u53d8\u4f53\u7d20\u7a7a\u95f4\u7ed3\u6784** \u7684\u524d\u63d0\u4e0b\uff0c\u5bf9\u540c\u4e00\u4f53\u7d20\u7684\u591a\u6e90\u7279\u5f81 \u8fdb\u884c\u901a\u9053\u7ea7\u878d\u5408\uff0c\u4ece\u800c\u83b7\u5f97\u66f4\u5177\u5224\u522b\u6027\u7684\u878d\u5408\u7279\u5f81\u3002 \u5728 VirConv \u6846\u67b6\u4e2d\uff0c\u672c\u7b97\u5b50\u4f4d\u4e8e NRConv (3D / 2D) \u4e4b\u540e\uff0c \u662f\u5b8c\u6210 **\u8de8\u7a7a\u95f4\u4fe1\u606f\u6574\u5408** \u7684\u5173\u952e\u4e00\u6b65\u3002 \u672c\u6a21\u5757\u5c5e\u4e8e **\u53ef\u5b66\u4e60\u7b97\u5b50**\uff0c\u5176\u53c2\u6570\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u6839\u636e\u76d1\u7763\u4fe1\u53f7\u8fdb\u884c\u66f4\u65b0\u3002 --- ### \u7ed3\u6784\u8bf4\u660e 1. **\u7279\u5f81\u62fc\u63a5\uff08Concat\uff09** - \u5c06 3D \u4e0e 2D \u7279\u5f81\u5728\u901a\u9053\u7ef4\u5ea6\u8fdb\u884c\u62fc\u63a5 2. **Linear \u6620\u5c04\uff08\u7b49\u4ef7\u4e8e 1\u00d71 Conv\uff09** - \u5bf9\u62fc\u63a5\u540e\u7684\u7279\u5f81\u8fdb\u884c\u901a\u9053\u538b\u7f29\u4e0e\u91cd\u6620\u5c04 3. **BatchNorm1d** - \u7a33\u5b9a\u7279\u5f81\u5206\u5e03\uff0c\u52a0\u901f\u8bad\u7ec3\u6536\u655b 4. **ReLU \u6fc0\u6d3b** - \u5f15\u5165\u975e\u7ebf\u6027\uff0c\u589e\u5f3a\u7279\u5f81\u8868\u8fbe\u80fd\u529b --- ### \u8f93\u5165 Args: feat_3d (torch.Tensor): \u6765\u81ea NRConv 3D \u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a **(M, C_3d)** feat_2d (torch.Tensor): \u6765\u81ea NRConv 2D \u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a **(M, C_2d)** --- ### \u8f93\u51fa Returns: torch.Tensor: \u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\u5f20\u91cf\uff0cshape \u4e3a **(M, C_out)** --- ### \u6a21\u5757\u7528\u9014 - \u878d\u5408\u4e09\u7ef4\u51e0\u4f55\u4fe1\u606f\u4e0e\u4e8c\u7ef4\u56fe\u50cf\u7ed3\u6784\u4fe1\u606f - \u63d0\u5347\u4f53\u7d20\u7279\u5f81\u5bf9\u865a\u62df\u70b9\u566a\u58f0\u7684\u9c81\u68d2\u6027 - \u4e3a\u540e\u7eed 3D SpConv Backbone \u63d0\u4f9b\u9ad8\u8d28\u91cf\u8f93\u5165\u7279\u5f81 - \u5c5e\u4e8e VirConv \u7684 Stage C\uff08NRConv\uff09\u672b\u7aef\u878d\u5408\u7b97\u5b50 \"\"\" def __init__ ( self , in_channels_3d : int , in_channels_2d : int , out_channels : int ): super () . __init__ () in_channels = in_channels_3d + in_channels_2d # \u62fc\u63a5\u540e\u7684\u901a\u9053\u6570 self . linear = nn . Linear ( in_channels , out_channels , bias = False ) # \u901a\u9053\u878d\u5408\u6620\u5c04 self . bn = nn . BatchNorm1d ( out_channels ) # \u6279\u5f52\u4e00\u5316 self . relu = nn . ReLU ( inplace = True ) # \u975e\u7ebf\u6027\u6fc0\u6d3b def forward ( self , feat_3d : torch . Tensor , feat_2d : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: feat_3d (torch.Tensor): 3D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_3d) feat_2d (torch.Tensor): 2D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_2d) Returns: torch.Tensor: \u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" if feat_3d . shape [ 0 ] != feat_2d . shape [ 0 ]: # \u68c0\u67e5\u4f53\u7d20\u6570\u91cf\u4e00\u81f4 raise ValueError ( \"feat_3d and feat_2d must have the same number of voxels\" ) x = torch . cat ([ feat_3d , feat_2d ], dim = 1 ) # \u901a\u9053\u62fc\u63a5 x = self . linear ( x ) # \u901a\u9053\u878d\u5408\u6620\u5c04 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x","title":"\u6a21\u5757\u7528\u9014"},{"location":"VirConvStage/#VirConvBlockStage.network.FeatureFusion.FeatureFusion.forward","text":"\u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Parameters: feat_3d ( Tensor ) \u2013 3D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_3d) feat_2d ( Tensor ) \u2013 2D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_2d) Returns: Tensor \u2013 torch.Tensor: \u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) Source code in VirConvBlockStage\\network\\FeatureFusion.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def forward ( self , feat_3d : torch . Tensor , feat_2d : torch . Tensor ) -> torch . Tensor : \"\"\" \u524d\u5411\u4f20\u64ad\u8fc7\u7a0b\u3002 Args: feat_3d (torch.Tensor): 3D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_3d) feat_2d (torch.Tensor): 2D \u5206\u652f\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_2d) Returns: torch.Tensor: \u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81\uff0cshape \u4e3a (M, C_out) \"\"\" if feat_3d . shape [ 0 ] != feat_2d . shape [ 0 ]: # \u68c0\u67e5\u4f53\u7d20\u6570\u91cf\u4e00\u81f4 raise ValueError ( \"feat_3d and feat_2d must have the same number of voxels\" ) x = torch . cat ([ feat_3d , feat_2d ], dim = 1 ) # \u901a\u9053\u62fc\u63a5 x = self . linear ( x ) # \u901a\u9053\u878d\u5408\u6620\u5c04 x = self . bn ( x ) # \u5f52\u4e00\u5316 x = self . relu ( x ) # \u6fc0\u6d3b return x","title":"forward"},{"location":"VoxelPreparationStage/","text":"Voxel Preparation Stage\uff08\u4f53\u7d20\u51c6\u5907\u9636\u6bb5\uff09 \u00b6 \u672c\u9636\u6bb5\u7684\u4f5c\u7528\u662f \u5bf9 LiDAR \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u8fdb\u884c\u7edf\u4e00\u9884\u5904\u7406\uff0c\u5e76\u6784\u5efa VirConv Block \u7684\u6807\u51c6\u8f93\u5165\u8868\u793a \u3002 \u8be5\u9636\u6bb5\u4e0d\u6d89\u53ca\u53ef\u5b66\u4e60\u53c2\u6570\uff0c\u4e3b\u8981\u7531 \u51e0\u4f55\u5904\u7406\u4e0e\u89c4\u5219\u5316\u7b97\u5b50 \u7ec4\u6210\uff0c\u4e3a\u540e\u7eed\u7a00\u758f\u5377\u79ef\u4e0e\u878d\u5408\u8ba1\u7b97\u5960\u5b9a\u57fa\u7840\u3002 \u9636\u6bb5\u76ee\u6807 \u00b6 Voxel Preparation Stage \u7684\u4e3b\u8981\u76ee\u6807\u5305\u62ec\uff1a \u878d\u5408\u771f\u5b9e LiDAR \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91 \u5bf9\u70b9\u7ea7\u6570\u636e\u8fdb\u884c\u5750\u6807\u5bf9\u9f50\u4e0e\u89c4\u5219\u5316 \u5c06\u4e0d\u89c4\u5219\u70b9\u4e91\u8f6c\u6362\u4e3a\u4f53\u7d20\u7ea7\u8868\u793a \u5f15\u5165\u8ddd\u79bb\u5206\u7bb1\u7b49\u5148\u9a8c\u4fe1\u606f\uff0c\u589e\u5f3a\u7a7a\u95f4\u5efa\u6a21\u80fd\u529b \u4e3a VirConv Block \u6784\u5efa STVD \u6240\u9700\u7684\u8f93\u5165\u7ed3\u6784 \u672c\u9636\u6bb5\u5305\u542b\u7684\u7b97\u5b50 \u00b6 \u672c\u9636\u6bb5\u5171\u5305\u542b 5 \u4e2a\u7b97\u5b50 \uff0c\u6267\u884c\u987a\u5e8f\u5982\u4e0b\uff1a stvd_input \u6784\u5efa STVD \u6240\u9700\u7684\u57fa\u7840\u8f93\u5165\u7ed3\u6784\u3002 point_fusion \u878d\u5408 LiDAR \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\uff0c\u5f62\u6210\u7edf\u4e00\u70b9\u96c6\u3002 point_align \u5bf9\u878d\u5408\u540e\u7684\u70b9\u4e91\u8fdb\u884c\u5750\u6807\u4e0e\u683c\u5f0f\u5bf9\u9f50\u3002 voxelization \u5c06\u70b9\u4e91\u8f6c\u6362\u4e3a\u7a00\u758f\u4f53\u7d20\u8868\u793a\u3002 distance_binning \u57fa\u4e8e\u4f53\u7d20\u4e2d\u5fc3\u7684\u7a7a\u95f4\u8ddd\u79bb\u8fdb\u884c\u5206\u7bb1\u7f16\u7801\u3002 API \u6587\u6863 \u00b6 \u4ee5\u4e0b API \u6587\u6863\u7531 \u4ee3\u7801\u6ce8\u91ca\u81ea\u52a8\u751f\u6210\uff08mkdocstrings\uff09 \u3002 stvd_input \u00b6 stvd_input ( voxel_coords , voxel_features , bin_ids , discard_rate ) \u00b6 \u5bf9\u8f93\u5165\u4f53\u7d20\u6267\u884c\u968f\u673a\u4e22\u5f03\uff08Input StVD\uff09\uff0c\u7528\u4e8e\u63a7\u5236\u4f53\u7d20\u6570\u91cf\u3002 Parameters: voxel_coords ( Tensor ) \u2013 (M, 3) \u8f93\u5165\u4f53\u7d20\u5750\u6807\u7d22\u5f15\u3002 voxel_features ( Tensor ) \u2013 (M, C) \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u3002 bin_ids ( Tensor ) \u2013 (M,) \u4f53\u7d20\u6240\u5c5e\u7684\u8ddd\u79bb bin\uff08\u7531\u7b97\u5b50 4 \u751f\u6210\uff09\u3002 discard_rate ( float ) \u2013 float \u4e22\u5f03\u6bd4\u4f8b\uff0c\u53d6\u503c\u8303\u56f4 [0, 1)\uff0c\u8868\u793a\u968f\u673a\u4e22\u5f03\u7684\u4f53\u7d20\u6bd4\u4f8b\u3002 Returns: voxel_coords_kept ( Tensor ) \u2013 (M', 3) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u5750\u6807\u3002 voxel_features_kept ( Tensor ) \u2013 (M', C) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u7279\u5f81\u3002 Source code in VoxelPreparationStage\\operator\\stvd_input.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @torch . library . custom_op ( \"virconv::stvd_input\" , mutates_args = []) def stvd_input ( voxel_coords : torch . Tensor , voxel_features : torch . Tensor , bin_ids : torch . Tensor , discard_rate : float ) -> Tuple [ torch . Tensor , torch . Tensor ]: \"\"\" \u5bf9\u8f93\u5165\u4f53\u7d20\u6267\u884c\u968f\u673a\u4e22\u5f03\uff08Input StVD\uff09\uff0c\u7528\u4e8e\u63a7\u5236\u4f53\u7d20\u6570\u91cf\u3002 Args: voxel_coords: (M, 3) \u8f93\u5165\u4f53\u7d20\u5750\u6807\u7d22\u5f15\u3002 voxel_features: (M, C) \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u3002 bin_ids: (M,) \u4f53\u7d20\u6240\u5c5e\u7684\u8ddd\u79bb bin\uff08\u7531\u7b97\u5b50 4 \u751f\u6210\uff09\u3002 discard_rate: float \u4e22\u5f03\u6bd4\u4f8b\uff0c\u53d6\u503c\u8303\u56f4 [0, 1)\uff0c\u8868\u793a\u968f\u673a\u4e22\u5f03\u7684\u4f53\u7d20\u6bd4\u4f8b\u3002 Returns: voxel_coords_kept: (M', 3) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u5750\u6807\u3002 voxel_features_kept: (M', C) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u7279\u5f81\u3002 \"\"\" if voxel_coords . ndim != 2 or voxel_coords . shape [ 1 ] != 3 : # \u68c0\u67e5\u5750\u6807 raise ValueError ( f \"voxel_coords must be (M,3), got { voxel_coords . shape } \" ) # \u62a5\u9519\u4fe1\u606f if voxel_features . ndim != 2 : # \u68c0\u67e5\u7279\u5f81 raise ValueError ( f \"voxel_features must be (M,C), got { voxel_features . shape } \" ) # \u62a5\u9519\u4fe1\u606f if voxel_coords . shape [ 0 ] != voxel_features . shape [ 0 ]: # \u6570\u91cf\u4e00\u81f4\u6027 raise ValueError ( \"voxel_coords and voxel_features must have same length\" ) # \u62a5\u9519\u4fe1\u606f if bin_ids . shape [ 0 ] != voxel_coords . shape [ 0 ]: # bin \u5bf9\u9f50 raise ValueError ( \"bin_ids must have same length as voxel_coords\" ) # \u62a5\u9519\u4fe1\u606f if discard_rate <= 0.0 : # \u4e0d\u4e22\u5f03 return voxel_coords . clone (), voxel_features . clone () # \u76f4\u63a5\u8fd4\u56de if discard_rate >= 1.0 : # \u5168\u4e22\u5f03\uff08\u6781\u7aef\u60c5\u51b5\uff09 return voxel_coords [: 0 ], voxel_features [: 0 ] # \u8fd4\u56de\u7a7a # \u4e3a\u6bcf\u4e2a\u4f53\u7d20\u751f\u6210\u968f\u673a\u4fdd\u7559\u6807\u8bb0 keep_prob = 1.0 - discard_rate # \u4fdd\u7559\u6982\u7387 rand = torch . rand ( ( voxel_coords . shape [ 0 ],), device = voxel_coords . device , dtype = torch . float32 , ) keep_mask = rand < keep_prob # \u662f\u5426\u4fdd\u7559 voxel_coords_kept = voxel_coords [ keep_mask ] # \u7b5b\u9009\u5750\u6807 voxel_features_kept = voxel_features [ keep_mask ] # \u7b5b\u9009\u7279\u5f81 return voxel_coords_kept , voxel_features_kept point_fusion \u00b6 point_fusion ( points_lidar , points_virtual ) \u00b6 \u5c06 LiDAR \u70b9\u4e91\u4e0e Virtual points \u8fdb\u884c\u878d\u5408\u62fc\u63a5\uff0c\u5e76\u8fd4\u56de\u878d\u5408\u540e\u7684\u70b9\u4e91\u5f20\u91cf\u3002 Parameters: points_lidar ( Tensor ) \u2013 (N, C) LiDAR \u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\u3002 points_virtual ( Tensor ) \u2013 (M, C) \u865a\u62df\u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\u3002 Returns: points_fused ( Tensor ) \u2013 (N+M, C) \u878d\u5408\u540e\u7684\u70b9\u4e91\u5f20\u91cf\uff0c\u6309\u884c\u62fc\u63a5 [points_lidar; points_virtual]\u3002 Source code in VoxelPreparationStage\\operator\\point_fusion.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @torch . library . custom_op ( \"virconv::point_fusion\" , mutates_args = []) def point_fusion ( points_lidar : torch . Tensor , points_virtual : torch . Tensor ) -> torch . Tensor : \"\"\" \u5c06 LiDAR \u70b9\u4e91\u4e0e Virtual points \u8fdb\u884c\u878d\u5408\u62fc\u63a5\uff0c\u5e76\u8fd4\u56de\u878d\u5408\u540e\u7684\u70b9\u4e91\u5f20\u91cf\u3002 Args: points_lidar: (N, C) LiDAR \u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\u3002 points_virtual: (M, C) \u865a\u62df\u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\u3002 Returns: points_fused: (N+M, C) \u878d\u5408\u540e\u7684\u70b9\u4e91\u5f20\u91cf\uff0c\u6309\u884c\u62fc\u63a5 [points_lidar; points_virtual]\u3002 \"\"\" if points_lidar . ndim != 2 : # \u68c0\u67e5\u7ef4\u5ea6 raise ValueError ( f \"points_lidar must be 2D (N,C), got { points_lidar . shape } \" ) # \u62a5\u9519\u4fe1\u606f if points_virtual . ndim != 2 : # \u68c0\u67e5\u7ef4\u5ea6 raise ValueError ( f \"points_virtual must be 2D (M,C), got { points_virtual . shape } \" ) # \u62a5\u9519\u4fe1\u606f if points_lidar . shape [ 1 ] != points_virtual . shape [ 1 ]: # \u68c0\u67e5\u7279\u5f81\u7ef4\u5ea6\u4e00\u81f4 raise ValueError ( f \"feature dim mismatch: lidar C= { points_lidar . shape [ 1 ] } vs virtual C= { points_virtual . shape [ 1 ] } \" ) # \u62a5\u9519\u4fe1\u606f if points_virtual . numel () == 0 : # \u5904\u7406\u7a7a\u865a\u62df\u70b9 return points_lidar # \u76f4\u63a5\u8fd4\u56de if points_lidar . numel () == 0 : # \u5904\u7406\u7a7a\u96f7\u8fbe\u70b9 return points_virtual # \u76f4\u63a5\u8fd4\u56de return torch . cat ([ points_lidar , points_virtual ], dim = 0 ) # \u884c\u62fc\u63a5\u878d\u5408 point_align \u00b6 point_align ( points ) \u00b6 \u5bf9\u878d\u5408\u540e\u7684\u70b9\u4e91\u8fdb\u884c\u7279\u5f81\u5bf9\u9f50\u5904\u7406\uff0c\u4fdd\u8bc1\u70b9\u7279\u5f81\u683c\u5f0f\u7edf\u4e00\u3002 Parameters: points ( Tensor ) \u2013 (N, C) \u8f93\u5165\u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\uff0c \u9ed8\u8ba4\u5047\u8bbe\u70b9\u7279\u5f81\u5df2\u7ecf\u662f\u7edf\u4e00\u683c\u5f0f\uff08\u5982 [x, y, z, intensity]\uff09\u3002 Returns: points_aligned ( Tensor ) \u2013 (N, C) \u7279\u5f81\u5bf9\u9f50\u540e\u7684\u70b9\u4e91\u5f20\u91cf\uff0c\u4e0e\u8f93\u5165\u5f62\u72b6\u4e00\u81f4\u3002 Source code in VoxelPreparationStage\\operator\\point_align.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @torch . library . custom_op ( \"virconv::point_align\" , mutates_args = []) def point_align ( points : torch . Tensor ) -> torch . Tensor : \"\"\" \u5bf9\u878d\u5408\u540e\u7684\u70b9\u4e91\u8fdb\u884c\u7279\u5f81\u5bf9\u9f50\u5904\u7406\uff0c\u4fdd\u8bc1\u70b9\u7279\u5f81\u683c\u5f0f\u7edf\u4e00\u3002 Args: points: (N, C) \u8f93\u5165\u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\uff0c \u9ed8\u8ba4\u5047\u8bbe\u70b9\u7279\u5f81\u5df2\u7ecf\u662f\u7edf\u4e00\u683c\u5f0f\uff08\u5982 [x, y, z, intensity]\uff09\u3002 Returns: points_aligned: (N, C) \u7279\u5f81\u5bf9\u9f50\u540e\u7684\u70b9\u4e91\u5f20\u91cf\uff0c\u4e0e\u8f93\u5165\u5f62\u72b6\u4e00\u81f4\u3002 \"\"\" if points . ndim != 2 : # \u68c0\u67e5\u7ef4\u5ea6 raise ValueError ( f \"points must be 2D (N,C), got { points . shape } \" ) # \u62a5\u9519\u4fe1\u606f # \u5f53\u524d\u7b97\u5b50\u4e0d\u4fee\u6539\u70b9\u7279\u5f81\uff0c\u4ec5\u4f5c\u4e3a\u5bf9\u9f50\u5360\u4f4d\u7b97\u5b50 return points . clone () voxelization \u00b6 voxelization ( points , voxel_size , point_cloud_range ) \u00b6 \u5c06\u70b9\u4e91\u6620\u5c04\u5230\u4f53\u7d20\u7f51\u683c\u4e2d\uff0c\u5e76\u751f\u6210\u4f53\u7d20\u5750\u6807\u4e0e\u4f53\u7d20\u7279\u5f81\u3002 Parameters: points ( Tensor ) \u2013 (N, C) \u8f93\u5165\u70b9\u4e91\u5f20\u91cf\uff0c\u524d 3 \u7ef4\u4e3a (x, y, z)\uff0c\u5176\u4f59\u4e3a\u70b9\u7279\u5f81\u3002 voxel_size ( Tensor ) \u2013 (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range ( Tensor ) \u2013 (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 Returns: voxel_coords ( Tensor ) \u2013 (M, 3) \u975e\u7a7a\u4f53\u7d20\u7684\u6574\u6570\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_features ( Tensor ) \u2013 (M, C) \u6bcf\u4e2a\u4f53\u7d20\u5bf9\u5e94\u7684\u7279\u5f81\uff0c\u91c7\u7528\u4f53\u7d20\u5185\u70b9\u7279\u5f81\u7684\u5747\u503c\u805a\u5408\u3002 Source code in VoxelPreparationStage\\operator\\voxelization.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @torch . library . custom_op ( \"virconv::voxelization\" , mutates_args = []) def voxelization ( points : torch . Tensor , voxel_size : torch . Tensor , point_cloud_range : torch . Tensor ) -> Tuple [ torch . Tensor , torch . Tensor ]: \"\"\" \u5c06\u70b9\u4e91\u6620\u5c04\u5230\u4f53\u7d20\u7f51\u683c\u4e2d\uff0c\u5e76\u751f\u6210\u4f53\u7d20\u5750\u6807\u4e0e\u4f53\u7d20\u7279\u5f81\u3002 Args: points: (N, C) \u8f93\u5165\u70b9\u4e91\u5f20\u91cf\uff0c\u524d 3 \u7ef4\u4e3a (x, y, z)\uff0c\u5176\u4f59\u4e3a\u70b9\u7279\u5f81\u3002 voxel_size: (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range: (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 Returns: voxel_coords: (M, 3) \u975e\u7a7a\u4f53\u7d20\u7684\u6574\u6570\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_features: (M, C) \u6bcf\u4e2a\u4f53\u7d20\u5bf9\u5e94\u7684\u7279\u5f81\uff0c\u91c7\u7528\u4f53\u7d20\u5185\u70b9\u7279\u5f81\u7684\u5747\u503c\u805a\u5408\u3002 \"\"\" if points . ndim != 2 : raise ValueError ( f \"points must be 2D (N,C), got { points . shape } \" ) if points . shape [ 1 ] < 3 : raise ValueError ( \"points must contain at least xyz coordinates\" ) # \u7edf\u4e00 device / dtype voxel_size = voxel_size . to ( device = points . device , dtype = torch . float32 ) point_cloud_range = point_cloud_range . to ( device = points . device , dtype = torch . float32 ) xyz = points [:, : 3 ] feats = points pc_min = point_cloud_range [: 3 ] pc_max = point_cloud_range [ 3 :] mask = (( xyz >= pc_min ) & ( xyz < pc_max )) . all ( dim = 1 ) xyz = xyz [ mask ] feats = feats [ mask ] if xyz . numel () == 0 : empty_coords = torch . empty (( 0 , 3 ), device = points . device , dtype = torch . int32 ) empty_feats = torch . empty (( 0 , feats . shape [ 1 ]), device = points . device , dtype = points . dtype ) return empty_coords , empty_feats voxel_coords = torch . floor (( xyz - pc_min ) / voxel_size ) . to ( torch . int32 ) unique_coords , inverse = torch . unique ( voxel_coords , dim = 0 , return_inverse = True ) voxel_features = torch . zeros ( ( unique_coords . shape [ 0 ], feats . shape [ 1 ]), device = feats . device , dtype = feats . dtype , ) voxel_features . index_add_ ( 0 , inverse , feats ) counts = torch . zeros (( unique_coords . shape [ 0 ], 1 ), device = feats . device , dtype = feats . dtype ) ones = torch . ones (( feats . shape [ 0 ], 1 ), device = feats . device , dtype = feats . dtype ) counts . index_add_ ( 0 , inverse , ones ) voxel_features = voxel_features / counts . clamp_min ( 1.0 ) # custom_op \u8f93\u51fa\u4e0d\u5141\u8bb8 alias\uff1a\u8fd9\u91cc\u672c\u6765\u5c31\u662f\u65b0\u5f20\u91cf\uff0c\u4f46 coords \u4e5f clone \u4e00\u4e0b\u66f4\u7a33 return unique_coords . clone (), voxel_features . clone () distance_binning \u00b6 distance_binning ( voxel_coords , voxel_size , point_cloud_range , bin_edges ) \u00b6 \u6839\u636e\u4f53\u7d20\u5728\u7a7a\u95f4\u4e2d\u7684\u8ddd\u79bb\uff0c\u5c06\u4f53\u7d20\u5212\u5206\u5230\u4e0d\u540c\u8ddd\u79bb bin \u4e2d\u3002 Parameters: voxel_coords ( Tensor ) \u2013 (M, 3) \u4f53\u7d20\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_size ( Tensor ) \u2013 (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range ( Tensor ) \u2013 (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 bin_edges ( Tensor ) \u2013 (K,) \u8ddd\u79bb\u5206\u6876\u8fb9\u754c\uff08\u9012\u589e\uff09\u3002 Returns: bin_ids ( Tensor ) \u2013 (M,) \u6bcf\u4e2a\u4f53\u7d20\u6240\u5c5e\u7684\u8ddd\u79bb bin \u7f16\u53f7\uff0c\u8303\u56f4 [0, K]\u3002 Source code in VoxelPreparationStage\\operator\\distance_binning.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @torch . library . custom_op ( \"virconv::distance_binning\" , mutates_args = []) def distance_binning ( voxel_coords : torch . Tensor , voxel_size : torch . Tensor , point_cloud_range : torch . Tensor , bin_edges : torch . Tensor ) -> torch . Tensor : \"\"\" \u6839\u636e\u4f53\u7d20\u5728\u7a7a\u95f4\u4e2d\u7684\u8ddd\u79bb\uff0c\u5c06\u4f53\u7d20\u5212\u5206\u5230\u4e0d\u540c\u8ddd\u79bb bin \u4e2d\u3002 Args: voxel_coords: (M, 3) \u4f53\u7d20\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_size: (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range: (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 bin_edges: (K,) \u8ddd\u79bb\u5206\u6876\u8fb9\u754c\uff08\u9012\u589e\uff09\u3002 Returns: bin_ids: (M,) \u6bcf\u4e2a\u4f53\u7d20\u6240\u5c5e\u7684\u8ddd\u79bb bin \u7f16\u53f7\uff0c\u8303\u56f4 [0, K]\u3002 \"\"\" if voxel_coords . ndim != 2 or voxel_coords . shape [ 1 ] != 3 : raise ValueError ( f \"voxel_coords must be (M,3), got { voxel_coords . shape } \" ) # \u7edf\u4e00 device / dtype device = voxel_coords . device voxel_size = voxel_size . to ( device = device , dtype = torch . float32 ) point_cloud_range = point_cloud_range . to ( device = device , dtype = torch . float32 ) bin_edges = bin_edges . to ( device = device , dtype = torch . float32 ) pc_min = point_cloud_range [: 3 ] centers = ( voxel_coords . to ( torch . float32 ) + 0.5 ) * voxel_size + pc_min # (M,3) distances = torch . linalg . norm ( centers , dim = 1 ) # (M,) bin_ids = torch . bucketize ( distances , bin_edges ) # (M,) return bin_ids . clone () # \u907f\u514d alias","title":"VoxelPreparationStage"},{"location":"VoxelPreparationStage/#voxel-preparation-stage","text":"\u672c\u9636\u6bb5\u7684\u4f5c\u7528\u662f \u5bf9 LiDAR \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u8fdb\u884c\u7edf\u4e00\u9884\u5904\u7406\uff0c\u5e76\u6784\u5efa VirConv Block \u7684\u6807\u51c6\u8f93\u5165\u8868\u793a \u3002 \u8be5\u9636\u6bb5\u4e0d\u6d89\u53ca\u53ef\u5b66\u4e60\u53c2\u6570\uff0c\u4e3b\u8981\u7531 \u51e0\u4f55\u5904\u7406\u4e0e\u89c4\u5219\u5316\u7b97\u5b50 \u7ec4\u6210\uff0c\u4e3a\u540e\u7eed\u7a00\u758f\u5377\u79ef\u4e0e\u878d\u5408\u8ba1\u7b97\u5960\u5b9a\u57fa\u7840\u3002","title":"Voxel Preparation Stage\uff08\u4f53\u7d20\u51c6\u5907\u9636\u6bb5\uff09"},{"location":"VoxelPreparationStage/#_1","text":"Voxel Preparation Stage \u7684\u4e3b\u8981\u76ee\u6807\u5305\u62ec\uff1a \u878d\u5408\u771f\u5b9e LiDAR \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91 \u5bf9\u70b9\u7ea7\u6570\u636e\u8fdb\u884c\u5750\u6807\u5bf9\u9f50\u4e0e\u89c4\u5219\u5316 \u5c06\u4e0d\u89c4\u5219\u70b9\u4e91\u8f6c\u6362\u4e3a\u4f53\u7d20\u7ea7\u8868\u793a \u5f15\u5165\u8ddd\u79bb\u5206\u7bb1\u7b49\u5148\u9a8c\u4fe1\u606f\uff0c\u589e\u5f3a\u7a7a\u95f4\u5efa\u6a21\u80fd\u529b \u4e3a VirConv Block \u6784\u5efa STVD \u6240\u9700\u7684\u8f93\u5165\u7ed3\u6784","title":"\u9636\u6bb5\u76ee\u6807"},{"location":"VoxelPreparationStage/#_2","text":"\u672c\u9636\u6bb5\u5171\u5305\u542b 5 \u4e2a\u7b97\u5b50 \uff0c\u6267\u884c\u987a\u5e8f\u5982\u4e0b\uff1a stvd_input \u6784\u5efa STVD \u6240\u9700\u7684\u57fa\u7840\u8f93\u5165\u7ed3\u6784\u3002 point_fusion \u878d\u5408 LiDAR \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\uff0c\u5f62\u6210\u7edf\u4e00\u70b9\u96c6\u3002 point_align \u5bf9\u878d\u5408\u540e\u7684\u70b9\u4e91\u8fdb\u884c\u5750\u6807\u4e0e\u683c\u5f0f\u5bf9\u9f50\u3002 voxelization \u5c06\u70b9\u4e91\u8f6c\u6362\u4e3a\u7a00\u758f\u4f53\u7d20\u8868\u793a\u3002 distance_binning \u57fa\u4e8e\u4f53\u7d20\u4e2d\u5fc3\u7684\u7a7a\u95f4\u8ddd\u79bb\u8fdb\u884c\u5206\u7bb1\u7f16\u7801\u3002","title":"\u672c\u9636\u6bb5\u5305\u542b\u7684\u7b97\u5b50"},{"location":"VoxelPreparationStage/#api","text":"\u4ee5\u4e0b API \u6587\u6863\u7531 \u4ee3\u7801\u6ce8\u91ca\u81ea\u52a8\u751f\u6210\uff08mkdocstrings\uff09 \u3002","title":"API \u6587\u6863"},{"location":"VoxelPreparationStage/#stvd_input","text":"","title":"stvd_input"},{"location":"VoxelPreparationStage/#VoxelPreparationStage.operator.stvd_input.stvd_input","text":"\u5bf9\u8f93\u5165\u4f53\u7d20\u6267\u884c\u968f\u673a\u4e22\u5f03\uff08Input StVD\uff09\uff0c\u7528\u4e8e\u63a7\u5236\u4f53\u7d20\u6570\u91cf\u3002 Parameters: voxel_coords ( Tensor ) \u2013 (M, 3) \u8f93\u5165\u4f53\u7d20\u5750\u6807\u7d22\u5f15\u3002 voxel_features ( Tensor ) \u2013 (M, C) \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u3002 bin_ids ( Tensor ) \u2013 (M,) \u4f53\u7d20\u6240\u5c5e\u7684\u8ddd\u79bb bin\uff08\u7531\u7b97\u5b50 4 \u751f\u6210\uff09\u3002 discard_rate ( float ) \u2013 float \u4e22\u5f03\u6bd4\u4f8b\uff0c\u53d6\u503c\u8303\u56f4 [0, 1)\uff0c\u8868\u793a\u968f\u673a\u4e22\u5f03\u7684\u4f53\u7d20\u6bd4\u4f8b\u3002 Returns: voxel_coords_kept ( Tensor ) \u2013 (M', 3) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u5750\u6807\u3002 voxel_features_kept ( Tensor ) \u2013 (M', C) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u7279\u5f81\u3002 Source code in VoxelPreparationStage\\operator\\stvd_input.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @torch . library . custom_op ( \"virconv::stvd_input\" , mutates_args = []) def stvd_input ( voxel_coords : torch . Tensor , voxel_features : torch . Tensor , bin_ids : torch . Tensor , discard_rate : float ) -> Tuple [ torch . Tensor , torch . Tensor ]: \"\"\" \u5bf9\u8f93\u5165\u4f53\u7d20\u6267\u884c\u968f\u673a\u4e22\u5f03\uff08Input StVD\uff09\uff0c\u7528\u4e8e\u63a7\u5236\u4f53\u7d20\u6570\u91cf\u3002 Args: voxel_coords: (M, 3) \u8f93\u5165\u4f53\u7d20\u5750\u6807\u7d22\u5f15\u3002 voxel_features: (M, C) \u8f93\u5165\u4f53\u7d20\u7279\u5f81\u3002 bin_ids: (M,) \u4f53\u7d20\u6240\u5c5e\u7684\u8ddd\u79bb bin\uff08\u7531\u7b97\u5b50 4 \u751f\u6210\uff09\u3002 discard_rate: float \u4e22\u5f03\u6bd4\u4f8b\uff0c\u53d6\u503c\u8303\u56f4 [0, 1)\uff0c\u8868\u793a\u968f\u673a\u4e22\u5f03\u7684\u4f53\u7d20\u6bd4\u4f8b\u3002 Returns: voxel_coords_kept: (M', 3) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u5750\u6807\u3002 voxel_features_kept: (M', C) \u4e22\u5f03\u540e\u4fdd\u7559\u7684\u4f53\u7d20\u7279\u5f81\u3002 \"\"\" if voxel_coords . ndim != 2 or voxel_coords . shape [ 1 ] != 3 : # \u68c0\u67e5\u5750\u6807 raise ValueError ( f \"voxel_coords must be (M,3), got { voxel_coords . shape } \" ) # \u62a5\u9519\u4fe1\u606f if voxel_features . ndim != 2 : # \u68c0\u67e5\u7279\u5f81 raise ValueError ( f \"voxel_features must be (M,C), got { voxel_features . shape } \" ) # \u62a5\u9519\u4fe1\u606f if voxel_coords . shape [ 0 ] != voxel_features . shape [ 0 ]: # \u6570\u91cf\u4e00\u81f4\u6027 raise ValueError ( \"voxel_coords and voxel_features must have same length\" ) # \u62a5\u9519\u4fe1\u606f if bin_ids . shape [ 0 ] != voxel_coords . shape [ 0 ]: # bin \u5bf9\u9f50 raise ValueError ( \"bin_ids must have same length as voxel_coords\" ) # \u62a5\u9519\u4fe1\u606f if discard_rate <= 0.0 : # \u4e0d\u4e22\u5f03 return voxel_coords . clone (), voxel_features . clone () # \u76f4\u63a5\u8fd4\u56de if discard_rate >= 1.0 : # \u5168\u4e22\u5f03\uff08\u6781\u7aef\u60c5\u51b5\uff09 return voxel_coords [: 0 ], voxel_features [: 0 ] # \u8fd4\u56de\u7a7a # \u4e3a\u6bcf\u4e2a\u4f53\u7d20\u751f\u6210\u968f\u673a\u4fdd\u7559\u6807\u8bb0 keep_prob = 1.0 - discard_rate # \u4fdd\u7559\u6982\u7387 rand = torch . rand ( ( voxel_coords . shape [ 0 ],), device = voxel_coords . device , dtype = torch . float32 , ) keep_mask = rand < keep_prob # \u662f\u5426\u4fdd\u7559 voxel_coords_kept = voxel_coords [ keep_mask ] # \u7b5b\u9009\u5750\u6807 voxel_features_kept = voxel_features [ keep_mask ] # \u7b5b\u9009\u7279\u5f81 return voxel_coords_kept , voxel_features_kept","title":"stvd_input"},{"location":"VoxelPreparationStage/#point_fusion","text":"","title":"point_fusion"},{"location":"VoxelPreparationStage/#VoxelPreparationStage.operator.point_fusion.point_fusion","text":"\u5c06 LiDAR \u70b9\u4e91\u4e0e Virtual points \u8fdb\u884c\u878d\u5408\u62fc\u63a5\uff0c\u5e76\u8fd4\u56de\u878d\u5408\u540e\u7684\u70b9\u4e91\u5f20\u91cf\u3002 Parameters: points_lidar ( Tensor ) \u2013 (N, C) LiDAR \u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\u3002 points_virtual ( Tensor ) \u2013 (M, C) \u865a\u62df\u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\u3002 Returns: points_fused ( Tensor ) \u2013 (N+M, C) \u878d\u5408\u540e\u7684\u70b9\u4e91\u5f20\u91cf\uff0c\u6309\u884c\u62fc\u63a5 [points_lidar; points_virtual]\u3002 Source code in VoxelPreparationStage\\operator\\point_fusion.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @torch . library . custom_op ( \"virconv::point_fusion\" , mutates_args = []) def point_fusion ( points_lidar : torch . Tensor , points_virtual : torch . Tensor ) -> torch . Tensor : \"\"\" \u5c06 LiDAR \u70b9\u4e91\u4e0e Virtual points \u8fdb\u884c\u878d\u5408\u62fc\u63a5\uff0c\u5e76\u8fd4\u56de\u878d\u5408\u540e\u7684\u70b9\u4e91\u5f20\u91cf\u3002 Args: points_lidar: (N, C) LiDAR \u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\u3002 points_virtual: (M, C) \u865a\u62df\u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\u3002 Returns: points_fused: (N+M, C) \u878d\u5408\u540e\u7684\u70b9\u4e91\u5f20\u91cf\uff0c\u6309\u884c\u62fc\u63a5 [points_lidar; points_virtual]\u3002 \"\"\" if points_lidar . ndim != 2 : # \u68c0\u67e5\u7ef4\u5ea6 raise ValueError ( f \"points_lidar must be 2D (N,C), got { points_lidar . shape } \" ) # \u62a5\u9519\u4fe1\u606f if points_virtual . ndim != 2 : # \u68c0\u67e5\u7ef4\u5ea6 raise ValueError ( f \"points_virtual must be 2D (M,C), got { points_virtual . shape } \" ) # \u62a5\u9519\u4fe1\u606f if points_lidar . shape [ 1 ] != points_virtual . shape [ 1 ]: # \u68c0\u67e5\u7279\u5f81\u7ef4\u5ea6\u4e00\u81f4 raise ValueError ( f \"feature dim mismatch: lidar C= { points_lidar . shape [ 1 ] } vs virtual C= { points_virtual . shape [ 1 ] } \" ) # \u62a5\u9519\u4fe1\u606f if points_virtual . numel () == 0 : # \u5904\u7406\u7a7a\u865a\u62df\u70b9 return points_lidar # \u76f4\u63a5\u8fd4\u56de if points_lidar . numel () == 0 : # \u5904\u7406\u7a7a\u96f7\u8fbe\u70b9 return points_virtual # \u76f4\u63a5\u8fd4\u56de return torch . cat ([ points_lidar , points_virtual ], dim = 0 ) # \u884c\u62fc\u63a5\u878d\u5408","title":"point_fusion"},{"location":"VoxelPreparationStage/#point_align","text":"","title":"point_align"},{"location":"VoxelPreparationStage/#VoxelPreparationStage.operator.point_align.point_align","text":"\u5bf9\u878d\u5408\u540e\u7684\u70b9\u4e91\u8fdb\u884c\u7279\u5f81\u5bf9\u9f50\u5904\u7406\uff0c\u4fdd\u8bc1\u70b9\u7279\u5f81\u683c\u5f0f\u7edf\u4e00\u3002 Parameters: points ( Tensor ) \u2013 (N, C) \u8f93\u5165\u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\uff0c \u9ed8\u8ba4\u5047\u8bbe\u70b9\u7279\u5f81\u5df2\u7ecf\u662f\u7edf\u4e00\u683c\u5f0f\uff08\u5982 [x, y, z, intensity]\uff09\u3002 Returns: points_aligned ( Tensor ) \u2013 (N, C) \u7279\u5f81\u5bf9\u9f50\u540e\u7684\u70b9\u4e91\u5f20\u91cf\uff0c\u4e0e\u8f93\u5165\u5f62\u72b6\u4e00\u81f4\u3002 Source code in VoxelPreparationStage\\operator\\point_align.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @torch . library . custom_op ( \"virconv::point_align\" , mutates_args = []) def point_align ( points : torch . Tensor ) -> torch . Tensor : \"\"\" \u5bf9\u878d\u5408\u540e\u7684\u70b9\u4e91\u8fdb\u884c\u7279\u5f81\u5bf9\u9f50\u5904\u7406\uff0c\u4fdd\u8bc1\u70b9\u7279\u5f81\u683c\u5f0f\u7edf\u4e00\u3002 Args: points: (N, C) \u8f93\u5165\u70b9\u4e91\u5f20\u91cf\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u70b9\uff0cC \u4e3a\u70b9\u7279\u5f81\u7ef4\u5ea6\uff0c \u9ed8\u8ba4\u5047\u8bbe\u70b9\u7279\u5f81\u5df2\u7ecf\u662f\u7edf\u4e00\u683c\u5f0f\uff08\u5982 [x, y, z, intensity]\uff09\u3002 Returns: points_aligned: (N, C) \u7279\u5f81\u5bf9\u9f50\u540e\u7684\u70b9\u4e91\u5f20\u91cf\uff0c\u4e0e\u8f93\u5165\u5f62\u72b6\u4e00\u81f4\u3002 \"\"\" if points . ndim != 2 : # \u68c0\u67e5\u7ef4\u5ea6 raise ValueError ( f \"points must be 2D (N,C), got { points . shape } \" ) # \u62a5\u9519\u4fe1\u606f # \u5f53\u524d\u7b97\u5b50\u4e0d\u4fee\u6539\u70b9\u7279\u5f81\uff0c\u4ec5\u4f5c\u4e3a\u5bf9\u9f50\u5360\u4f4d\u7b97\u5b50 return points . clone ()","title":"point_align"},{"location":"VoxelPreparationStage/#voxelization","text":"","title":"voxelization"},{"location":"VoxelPreparationStage/#VoxelPreparationStage.operator.voxelization.voxelization","text":"\u5c06\u70b9\u4e91\u6620\u5c04\u5230\u4f53\u7d20\u7f51\u683c\u4e2d\uff0c\u5e76\u751f\u6210\u4f53\u7d20\u5750\u6807\u4e0e\u4f53\u7d20\u7279\u5f81\u3002 Parameters: points ( Tensor ) \u2013 (N, C) \u8f93\u5165\u70b9\u4e91\u5f20\u91cf\uff0c\u524d 3 \u7ef4\u4e3a (x, y, z)\uff0c\u5176\u4f59\u4e3a\u70b9\u7279\u5f81\u3002 voxel_size ( Tensor ) \u2013 (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range ( Tensor ) \u2013 (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 Returns: voxel_coords ( Tensor ) \u2013 (M, 3) \u975e\u7a7a\u4f53\u7d20\u7684\u6574\u6570\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_features ( Tensor ) \u2013 (M, C) \u6bcf\u4e2a\u4f53\u7d20\u5bf9\u5e94\u7684\u7279\u5f81\uff0c\u91c7\u7528\u4f53\u7d20\u5185\u70b9\u7279\u5f81\u7684\u5747\u503c\u805a\u5408\u3002 Source code in VoxelPreparationStage\\operator\\voxelization.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @torch . library . custom_op ( \"virconv::voxelization\" , mutates_args = []) def voxelization ( points : torch . Tensor , voxel_size : torch . Tensor , point_cloud_range : torch . Tensor ) -> Tuple [ torch . Tensor , torch . Tensor ]: \"\"\" \u5c06\u70b9\u4e91\u6620\u5c04\u5230\u4f53\u7d20\u7f51\u683c\u4e2d\uff0c\u5e76\u751f\u6210\u4f53\u7d20\u5750\u6807\u4e0e\u4f53\u7d20\u7279\u5f81\u3002 Args: points: (N, C) \u8f93\u5165\u70b9\u4e91\u5f20\u91cf\uff0c\u524d 3 \u7ef4\u4e3a (x, y, z)\uff0c\u5176\u4f59\u4e3a\u70b9\u7279\u5f81\u3002 voxel_size: (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range: (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 Returns: voxel_coords: (M, 3) \u975e\u7a7a\u4f53\u7d20\u7684\u6574\u6570\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_features: (M, C) \u6bcf\u4e2a\u4f53\u7d20\u5bf9\u5e94\u7684\u7279\u5f81\uff0c\u91c7\u7528\u4f53\u7d20\u5185\u70b9\u7279\u5f81\u7684\u5747\u503c\u805a\u5408\u3002 \"\"\" if points . ndim != 2 : raise ValueError ( f \"points must be 2D (N,C), got { points . shape } \" ) if points . shape [ 1 ] < 3 : raise ValueError ( \"points must contain at least xyz coordinates\" ) # \u7edf\u4e00 device / dtype voxel_size = voxel_size . to ( device = points . device , dtype = torch . float32 ) point_cloud_range = point_cloud_range . to ( device = points . device , dtype = torch . float32 ) xyz = points [:, : 3 ] feats = points pc_min = point_cloud_range [: 3 ] pc_max = point_cloud_range [ 3 :] mask = (( xyz >= pc_min ) & ( xyz < pc_max )) . all ( dim = 1 ) xyz = xyz [ mask ] feats = feats [ mask ] if xyz . numel () == 0 : empty_coords = torch . empty (( 0 , 3 ), device = points . device , dtype = torch . int32 ) empty_feats = torch . empty (( 0 , feats . shape [ 1 ]), device = points . device , dtype = points . dtype ) return empty_coords , empty_feats voxel_coords = torch . floor (( xyz - pc_min ) / voxel_size ) . to ( torch . int32 ) unique_coords , inverse = torch . unique ( voxel_coords , dim = 0 , return_inverse = True ) voxel_features = torch . zeros ( ( unique_coords . shape [ 0 ], feats . shape [ 1 ]), device = feats . device , dtype = feats . dtype , ) voxel_features . index_add_ ( 0 , inverse , feats ) counts = torch . zeros (( unique_coords . shape [ 0 ], 1 ), device = feats . device , dtype = feats . dtype ) ones = torch . ones (( feats . shape [ 0 ], 1 ), device = feats . device , dtype = feats . dtype ) counts . index_add_ ( 0 , inverse , ones ) voxel_features = voxel_features / counts . clamp_min ( 1.0 ) # custom_op \u8f93\u51fa\u4e0d\u5141\u8bb8 alias\uff1a\u8fd9\u91cc\u672c\u6765\u5c31\u662f\u65b0\u5f20\u91cf\uff0c\u4f46 coords \u4e5f clone \u4e00\u4e0b\u66f4\u7a33 return unique_coords . clone (), voxel_features . clone ()","title":"voxelization"},{"location":"VoxelPreparationStage/#distance_binning","text":"","title":"distance_binning"},{"location":"VoxelPreparationStage/#VoxelPreparationStage.operator.distance_binning.distance_binning","text":"\u6839\u636e\u4f53\u7d20\u5728\u7a7a\u95f4\u4e2d\u7684\u8ddd\u79bb\uff0c\u5c06\u4f53\u7d20\u5212\u5206\u5230\u4e0d\u540c\u8ddd\u79bb bin \u4e2d\u3002 Parameters: voxel_coords ( Tensor ) \u2013 (M, 3) \u4f53\u7d20\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_size ( Tensor ) \u2013 (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range ( Tensor ) \u2013 (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 bin_edges ( Tensor ) \u2013 (K,) \u8ddd\u79bb\u5206\u6876\u8fb9\u754c\uff08\u9012\u589e\uff09\u3002 Returns: bin_ids ( Tensor ) \u2013 (M,) \u6bcf\u4e2a\u4f53\u7d20\u6240\u5c5e\u7684\u8ddd\u79bb bin \u7f16\u53f7\uff0c\u8303\u56f4 [0, K]\u3002 Source code in VoxelPreparationStage\\operator\\distance_binning.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @torch . library . custom_op ( \"virconv::distance_binning\" , mutates_args = []) def distance_binning ( voxel_coords : torch . Tensor , voxel_size : torch . Tensor , point_cloud_range : torch . Tensor , bin_edges : torch . Tensor ) -> torch . Tensor : \"\"\" \u6839\u636e\u4f53\u7d20\u5728\u7a7a\u95f4\u4e2d\u7684\u8ddd\u79bb\uff0c\u5c06\u4f53\u7d20\u5212\u5206\u5230\u4e0d\u540c\u8ddd\u79bb bin \u4e2d\u3002 Args: voxel_coords: (M, 3) \u4f53\u7d20\u5750\u6807\u7d22\u5f15 (ix, iy, iz)\u3002 voxel_size: (3,) \u4f53\u7d20\u5c3a\u5bf8 [vx, vy, vz]\u3002 point_cloud_range: (6,) \u70b9\u4e91\u8303\u56f4 [x_min, y_min, z_min, x_max, y_max, z_max]\u3002 bin_edges: (K,) \u8ddd\u79bb\u5206\u6876\u8fb9\u754c\uff08\u9012\u589e\uff09\u3002 Returns: bin_ids: (M,) \u6bcf\u4e2a\u4f53\u7d20\u6240\u5c5e\u7684\u8ddd\u79bb bin \u7f16\u53f7\uff0c\u8303\u56f4 [0, K]\u3002 \"\"\" if voxel_coords . ndim != 2 or voxel_coords . shape [ 1 ] != 3 : raise ValueError ( f \"voxel_coords must be (M,3), got { voxel_coords . shape } \" ) # \u7edf\u4e00 device / dtype device = voxel_coords . device voxel_size = voxel_size . to ( device = device , dtype = torch . float32 ) point_cloud_range = point_cloud_range . to ( device = device , dtype = torch . float32 ) bin_edges = bin_edges . to ( device = device , dtype = torch . float32 ) pc_min = point_cloud_range [: 3 ] centers = ( voxel_coords . to ( torch . float32 ) + 0.5 ) * voxel_size + pc_min # (M,3) distances = torch . linalg . norm ( centers , dim = 1 ) # (M,) bin_ids = torch . bucketize ( distances , bin_edges ) # (M,) return bin_ids . clone () # \u907f\u514d alias","title":"distance_binning"},{"location":"framework/","text":"VirConv Framework\uff08\u6574\u4f53\u6846\u67b6\uff09 \u00b6 VirConv Framework \u7528\u4e8e \u7edf\u4e00\u7ec4\u7ec7\u5e76\u8c03\u5ea6\u5404\u9636\u6bb5\u7b97\u5b50\u4e0e\u6a21\u5757 \uff0c \u6784\u6210\u4ece\u70b9\u4e91\u8f93\u5165\u5230\u878d\u5408\u4f53\u7d20\u7279\u5f81\u8f93\u51fa\u7684\u5b8c\u6574\u524d\u5411\u8ba1\u7b97\u6d41\u7a0b\u3002 \u8be5\u6846\u67b6\u672c\u8eab\u4e0d\u5f15\u5165\u65b0\u7684\u8ba1\u7b97\u903b\u8f91\uff0c\u800c\u662f\u6309\u7167\u65e2\u5b9a\u987a\u5e8f\u4e32\u8054\u5404\u9636\u6bb5\u7b97\u5b50\u3002 \u6846\u67b6\u7ec4\u6210 \u00b6 VirConv Framework \u4e3b\u8981\u7531\u4ee5\u4e0b\u90e8\u5206\u6784\u6210\uff1a Virtual Point Generator \u7528\u4e8e\u751f\u6210\u4f2a\u70b9\u4e91\uff08Demo \u4e2d\u53ef\u4f7f\u7528 Simple \u5b9e\u73b0\uff09\u3002 Voxel Preparation Stage \u5bf9\u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u8fdb\u884c\u878d\u5408\u4e0e\u4f53\u7d20\u5316\u5904\u7406\u3002 VirConv Stage \u6267\u884c VirConv Block \u7684\u6838\u5fc3\u8ba1\u7b97\u3002 \u524d\u5411\u6267\u884c\u6d41\u7a0b \u00b6 \u6846\u67b6\u5728\u524d\u5411\u8fc7\u7a0b\u4e2d\u4f9d\u6b21\u5b8c\u6210\u4ee5\u4e0b\u6b65\u9aa4\uff1a \u751f\u6210\u6216\u63a5\u6536\u4f2a\u70b9\u4e91 \u8c03\u7528 Voxel Preparation Stage \u6784\u5efa\u4f53\u7d20\u7ea7\u8f93\u5165 \u8c03\u7528 VirConv Stage \u8fdb\u884c\u7279\u5f81\u878d\u5408\u8ba1\u7b97 \u8f93\u51fa\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81 API \u6587\u6863 \u00b6 VirConvFramework \u00b6 Bases: Module VirConv Framework\u3002 \u8be5\u6846\u67b6\u7528\u4e8e\u5c06 VirConv \u65b9\u6cd5\u4e2d\u7684\u5404\u4e2a\u7b97\u5b50\u4e0e\u7f51\u7edc\u6a21\u5757\u6309\u7167\u65e2\u5b9a\u987a\u5e8f \u8fdb\u884c\u7ec4\u7ec7\u4e0e\u8c03\u5ea6\uff0c\u6784\u6210\u4ece LiDAR \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u8f93\u5165\u5230\u878d\u5408\u4f53\u7d20\u7279\u5f81\u8f93\u51fa\u7684 \u5b8c\u6574\u524d\u5411\u8ba1\u7b97\u6d41\u7a0b\u3002 \u672c\u6846\u67b6\u672c\u8eab\u4e0d\u5f15\u5165\u65b0\u7684\u51e0\u4f55\u6216\u878d\u5408\u903b\u8f91\uff0c\u800c\u662f\u4f5c\u4e3a\u4e00\u4e2a Pipeline / Orchestrator \uff0c \u4e32\u8054\u4ee5\u4e0b\u4e24\u4e2a\u4e3b\u8981\u9636\u6bb5\uff1a Voxel Preparation Stage\uff08\u4f53\u7d20\u51c6\u5907\u9636\u6bb5\uff09 VirConv Block Stage\uff08VirConv \u6838\u5fc3\u8ba1\u7b97\u9636\u6bb5\uff09 \u6240\u6709\u4e0d\u53ef\u5b66\u4e60\u7b97\u5b50\u5747\u901a\u8fc7 torch.ops.virconv.* \u5f62\u5f0f\u8c03\u7528\uff0c \u53ef\u5b66\u4e60\u6a21\u5757\u5219\u4ee5 nn.Module \u7684\u5f62\u5f0f\u6ce8\u518c\u5728\u6846\u67b6\u4e2d\u3002 Args: virtual_point_generator (VirtualPointGeneratorInterface): \u4f2a\u70b9\u4e91\u751f\u6210\u5668\u63a5\u53e3\uff0c\u7528\u4e8e\u4ece\u56fe\u50cf\u6216\u5176\u4ed6\u6a21\u6001\u4fe1\u606f\u4e2d\u751f\u6210\u865a\u62df\u70b9\u4e91\u3002 \u5728 Demo \u4e2d\u53ef\u4f7f\u7528 Simple \u5b9e\u73b0\u3002 voxel_size (Tuple[float, float, float]): \u4f53\u7d20\u5927\u5c0f (vx, vy, vz)\uff0c\u7528\u4e8e\u70b9\u4e91\u4f53\u7d20\u5316\u3002 point_cloud_range (Tuple[float, float, float, float, float, float]): \u70b9\u4e91\u7a7a\u95f4\u8303\u56f4 (x_min, y_min, z_min, x_max, y_max, z_max)\u3002 bin_edges (torch.Tensor): \u8ddd\u79bb\u5206\u7bb1\u7684\u8fb9\u754c\uff0c\u7528\u4e8e distance_binning \u7b97\u5b50\u3002 input_discard_rate (float): STVD \u8f93\u5165\u9636\u6bb5\u7684\u70b9\u4e91\u4e22\u5f03\u6bd4\u4f8b\uff0c\u7528\u4e8e\u6291\u5236\u5197\u4f59\u865a\u62df\u70b9\u3002 layer_discard_rate (float): STVD Layer \u5185\u90e8\u7684\u4f53\u7d20\u4e22\u5f03\u6bd4\u4f8b\u3002 feat_dim (int): \u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6\u3002 Source code in framework.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class VirConvFramework ( torch . nn . Module ): \"\"\" VirConv Framework\u3002 \u8be5\u6846\u67b6\u7528\u4e8e\u5c06 VirConv \u65b9\u6cd5\u4e2d\u7684\u5404\u4e2a\u7b97\u5b50\u4e0e\u7f51\u7edc\u6a21\u5757\u6309\u7167\u65e2\u5b9a\u987a\u5e8f \u8fdb\u884c\u7ec4\u7ec7\u4e0e\u8c03\u5ea6\uff0c\u6784\u6210\u4ece LiDAR \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u8f93\u5165\u5230\u878d\u5408\u4f53\u7d20\u7279\u5f81\u8f93\u51fa\u7684 \u5b8c\u6574\u524d\u5411\u8ba1\u7b97\u6d41\u7a0b\u3002 \u672c\u6846\u67b6\u672c\u8eab\u4e0d\u5f15\u5165\u65b0\u7684\u51e0\u4f55\u6216\u878d\u5408\u903b\u8f91\uff0c\u800c\u662f\u4f5c\u4e3a\u4e00\u4e2a **Pipeline / Orchestrator**\uff0c \u4e32\u8054\u4ee5\u4e0b\u4e24\u4e2a\u4e3b\u8981\u9636\u6bb5\uff1a - Voxel Preparation Stage\uff08\u4f53\u7d20\u51c6\u5907\u9636\u6bb5\uff09 - VirConv Block Stage\uff08VirConv \u6838\u5fc3\u8ba1\u7b97\u9636\u6bb5\uff09 \u6240\u6709\u4e0d\u53ef\u5b66\u4e60\u7b97\u5b50\u5747\u901a\u8fc7 `torch.ops.virconv.*` \u5f62\u5f0f\u8c03\u7528\uff0c \u53ef\u5b66\u4e60\u6a21\u5757\u5219\u4ee5 `nn.Module` \u7684\u5f62\u5f0f\u6ce8\u518c\u5728\u6846\u67b6\u4e2d\u3002 --- Args: virtual_point_generator (VirtualPointGeneratorInterface): \u4f2a\u70b9\u4e91\u751f\u6210\u5668\u63a5\u53e3\uff0c\u7528\u4e8e\u4ece\u56fe\u50cf\u6216\u5176\u4ed6\u6a21\u6001\u4fe1\u606f\u4e2d\u751f\u6210\u865a\u62df\u70b9\u4e91\u3002 \u5728 Demo \u4e2d\u53ef\u4f7f\u7528 Simple \u5b9e\u73b0\u3002 voxel_size (Tuple[float, float, float]): \u4f53\u7d20\u5927\u5c0f (vx, vy, vz)\uff0c\u7528\u4e8e\u70b9\u4e91\u4f53\u7d20\u5316\u3002 point_cloud_range (Tuple[float, float, float, float, float, float]): \u70b9\u4e91\u7a7a\u95f4\u8303\u56f4 (x_min, y_min, z_min, x_max, y_max, z_max)\u3002 bin_edges (torch.Tensor): \u8ddd\u79bb\u5206\u7bb1\u7684\u8fb9\u754c\uff0c\u7528\u4e8e distance_binning \u7b97\u5b50\u3002 input_discard_rate (float): STVD \u8f93\u5165\u9636\u6bb5\u7684\u70b9\u4e91\u4e22\u5f03\u6bd4\u4f8b\uff0c\u7528\u4e8e\u6291\u5236\u5197\u4f59\u865a\u62df\u70b9\u3002 layer_discard_rate (float): STVD Layer \u5185\u90e8\u7684\u4f53\u7d20\u4e22\u5f03\u6bd4\u4f8b\u3002 feat_dim (int): \u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6\u3002 \"\"\" def __init__ ( self , virtual_point_generator : VirtualPointGeneratorInterface , voxel_size : Tuple [ float , float , float ], point_cloud_range : Tuple [ float , float , float , float , float , float ], bin_edges : torch . Tensor , input_discard_rate : float , layer_discard_rate : float , feat_dim : int ): super () . __init__ () self . virtual_point_generator = virtual_point_generator self . voxel_size = torch . tensor ( voxel_size , dtype = torch . float32 ) self . point_cloud_range = torch . tensor ( point_cloud_range , dtype = torch . float32 ) self . bin_edges = bin_edges self . input_discard_rate = input_discard_rate self . layer_discard_rate = layer_discard_rate # ===== \u53ef\u5b66\u4e60\u6a21\u5757 ===== self . nrconv3d = NRConv3D ( feat_dim , feat_dim ) self . nrconv2d = NRConv2D ( feat_dim , feat_dim ) self . fusion = FeatureFusion ( feat_dim , feat_dim , feat_dim ) self . spconv3d = SparseConv3D ( feat_dim , feat_dim ) def forward ( self , lidar_points : torch . Tensor , image : Optional [ torch . Tensor ] = None , calib : Optional [ dict ] = None , proj_matrix : Optional [ torch . Tensor ] = None , training : bool = True ): \"\"\" \u6267\u884c\u5b8c\u6574\u7684 VirConv \u524d\u5411\u6d41\u7a0b\u3002 \u8be5\u51fd\u6570\u6309\u7167 VirConv \u7684\u6807\u51c6\u8ba1\u7b97\u987a\u5e8f\uff0c\u4f9d\u6b21\u5b8c\u6210\uff1a 1. \u4f2a\u70b9\u4e91\u751f\u6210 2. \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u878d\u5408 3. \u4f53\u7d20\u5316\u4e0e STVD \u8f93\u5165\u6784\u5efa 4. VirConv Block \u6838\u5fc3\u8ba1\u7b97 5. \u8f93\u51fa\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81 --- Args: lidar_points (torch.Tensor): \u8f93\u5165 LiDAR \u70b9\u4e91\uff0cshape \u4e3a (N, C)\uff0c \u7531\u6570\u636e\u96c6\u6216 3D \u68c0\u6d4b\u5668\u9884\u5904\u7406\u6a21\u5757\u63d0\u4f9b\u3002 image (torch.Tensor, optional): \u8f93\u5165\u56fe\u50cf\u6570\u636e\uff0c\u7528\u4e8e\u4f2a\u70b9\u4e91\u751f\u6210\u6216 2D \u6295\u5f71\u76f8\u5173\u8ba1\u7b97\u3002 \u5728 Fake Demo \u4e2d\u53ef\u4e3a None\u3002 calib (dict, optional): \u6807\u5b9a\u53c2\u6570\u5b57\u5178\uff0c\u901a\u5e38\u5305\u542b LiDAR \u4e0e Camera \u4e4b\u95f4\u7684\u5916\u53c2\u53ca\u6295\u5f71\u77e9\u9635\u3002 proj_matrix (torch.Tensor, optional): 3D \u2192 2D \u6295\u5f71\u77e9\u9635\uff0c\u7528\u4e8e projection \u7b97\u5b50\u3002 training (bool): \u662f\u5426\u5904\u4e8e\u8bad\u7ec3\u9636\u6bb5\uff0c\u7528\u4e8e\u63a7\u5236 STVD Layer \u4e2d\u7684\u968f\u673a\u4e22\u5f03\u884c\u4e3a\u3002 --- Returns: out_feat (torch.Tensor): \u878d\u5408\u540e\u7684\u7a00\u758f\u4f53\u7d20\u7279\u5f81\uff0c\u4f5c\u4e3a VirConv Block \u7684\u6700\u7ec8\u8f93\u51fa\uff0c \u53ef\u76f4\u63a5\u5bf9\u63a5\u4e0b\u6e38 3D \u68c0\u6d4b\u5934\u6216\u5176\u4ed6\u4efb\u52a1\u6a21\u5757\u3002 \"\"\" # ===== 0. Virtual points (interface) ===== virtual_points = self . generate_virtual_points ( lidar_points , image = image , calib = calib ) # ===== Stage A: Voxel Preparation (torch.ops) ===== points = torch . ops . virconv . point_fusion ( # 1 lidar_points , virtual_points ) points = torch . ops . virconv . point_align ( # 2 points ) voxel_coords , voxel_features = torch . ops . virconv . voxelization ( # 3 points , self . voxel_size , self . point_cloud_range ) bin_ids = torch . ops . virconv . distance_binning ( # 4 voxel_coords , self . voxel_size , self . point_cloud_range , self . bin_edges ) voxel_coords , voxel_features = torch . ops . virconv . stvd_input ( # 5 voxel_coords , voxel_features , bin_ids , self . input_discard_rate ) # ===== Stage B/C: VirConv Block ===== voxel_coords , voxel_features = torch . ops . virconv . stvd_layer ( # 6 voxel_coords , voxel_features , self . layer_discard_rate , training ) feat_3d = self . nrconv3d ( voxel_features ) # 7 pixel_coords = torch . ops . virconv . projection ( # 8 voxel_coords , self . voxel_size , self . point_cloud_range , proj_matrix ) feat_2d = self . nrconv2d ( feat_3d , pixel_coords ) # 9 fused_feat = self . fusion ( feat_3d , feat_2d ) # 10 out_feat = self . spconv3d ( fused_feat ) # 11 return out_feat forward ( lidar_points , image = None , calib = None , proj_matrix = None , training = True ) \u00b6 \u6267\u884c\u5b8c\u6574\u7684 VirConv \u524d\u5411\u6d41\u7a0b\u3002 \u8be5\u51fd\u6570\u6309\u7167 VirConv \u7684\u6807\u51c6\u8ba1\u7b97\u987a\u5e8f\uff0c\u4f9d\u6b21\u5b8c\u6210\uff1a 1. \u4f2a\u70b9\u4e91\u751f\u6210 2. \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u878d\u5408 3. \u4f53\u7d20\u5316\u4e0e STVD \u8f93\u5165\u6784\u5efa 4. VirConv Block \u6838\u5fc3\u8ba1\u7b97 5. \u8f93\u51fa\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81 Args: lidar_points (torch.Tensor): \u8f93\u5165 LiDAR \u70b9\u4e91\uff0cshape \u4e3a (N, C)\uff0c \u7531\u6570\u636e\u96c6\u6216 3D \u68c0\u6d4b\u5668\u9884\u5904\u7406\u6a21\u5757\u63d0\u4f9b\u3002 image (torch.Tensor, optional): \u8f93\u5165\u56fe\u50cf\u6570\u636e\uff0c\u7528\u4e8e\u4f2a\u70b9\u4e91\u751f\u6210\u6216 2D \u6295\u5f71\u76f8\u5173\u8ba1\u7b97\u3002 \u5728 Fake Demo \u4e2d\u53ef\u4e3a None\u3002 calib (dict, optional): \u6807\u5b9a\u53c2\u6570\u5b57\u5178\uff0c\u901a\u5e38\u5305\u542b LiDAR \u4e0e Camera \u4e4b\u95f4\u7684\u5916\u53c2\u53ca\u6295\u5f71\u77e9\u9635\u3002 proj_matrix (torch.Tensor, optional): 3D \u2192 2D \u6295\u5f71\u77e9\u9635\uff0c\u7528\u4e8e projection \u7b97\u5b50\u3002 training (bool): \u662f\u5426\u5904\u4e8e\u8bad\u7ec3\u9636\u6bb5\uff0c\u7528\u4e8e\u63a7\u5236 STVD Layer \u4e2d\u7684\u968f\u673a\u4e22\u5f03\u884c\u4e3a\u3002 Returns: out_feat (torch.Tensor): \u878d\u5408\u540e\u7684\u7a00\u758f\u4f53\u7d20\u7279\u5f81\uff0c\u4f5c\u4e3a VirConv Block \u7684\u6700\u7ec8\u8f93\u51fa\uff0c \u53ef\u76f4\u63a5\u5bf9\u63a5\u4e0b\u6e38 3D \u68c0\u6d4b\u5934\u6216\u5176\u4ed6\u4efb\u52a1\u6a21\u5757\u3002 Source code in framework.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def forward ( self , lidar_points : torch . Tensor , image : Optional [ torch . Tensor ] = None , calib : Optional [ dict ] = None , proj_matrix : Optional [ torch . Tensor ] = None , training : bool = True ): \"\"\" \u6267\u884c\u5b8c\u6574\u7684 VirConv \u524d\u5411\u6d41\u7a0b\u3002 \u8be5\u51fd\u6570\u6309\u7167 VirConv \u7684\u6807\u51c6\u8ba1\u7b97\u987a\u5e8f\uff0c\u4f9d\u6b21\u5b8c\u6210\uff1a 1. \u4f2a\u70b9\u4e91\u751f\u6210 2. \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u878d\u5408 3. \u4f53\u7d20\u5316\u4e0e STVD \u8f93\u5165\u6784\u5efa 4. VirConv Block \u6838\u5fc3\u8ba1\u7b97 5. \u8f93\u51fa\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81 --- Args: lidar_points (torch.Tensor): \u8f93\u5165 LiDAR \u70b9\u4e91\uff0cshape \u4e3a (N, C)\uff0c \u7531\u6570\u636e\u96c6\u6216 3D \u68c0\u6d4b\u5668\u9884\u5904\u7406\u6a21\u5757\u63d0\u4f9b\u3002 image (torch.Tensor, optional): \u8f93\u5165\u56fe\u50cf\u6570\u636e\uff0c\u7528\u4e8e\u4f2a\u70b9\u4e91\u751f\u6210\u6216 2D \u6295\u5f71\u76f8\u5173\u8ba1\u7b97\u3002 \u5728 Fake Demo \u4e2d\u53ef\u4e3a None\u3002 calib (dict, optional): \u6807\u5b9a\u53c2\u6570\u5b57\u5178\uff0c\u901a\u5e38\u5305\u542b LiDAR \u4e0e Camera \u4e4b\u95f4\u7684\u5916\u53c2\u53ca\u6295\u5f71\u77e9\u9635\u3002 proj_matrix (torch.Tensor, optional): 3D \u2192 2D \u6295\u5f71\u77e9\u9635\uff0c\u7528\u4e8e projection \u7b97\u5b50\u3002 training (bool): \u662f\u5426\u5904\u4e8e\u8bad\u7ec3\u9636\u6bb5\uff0c\u7528\u4e8e\u63a7\u5236 STVD Layer \u4e2d\u7684\u968f\u673a\u4e22\u5f03\u884c\u4e3a\u3002 --- Returns: out_feat (torch.Tensor): \u878d\u5408\u540e\u7684\u7a00\u758f\u4f53\u7d20\u7279\u5f81\uff0c\u4f5c\u4e3a VirConv Block \u7684\u6700\u7ec8\u8f93\u51fa\uff0c \u53ef\u76f4\u63a5\u5bf9\u63a5\u4e0b\u6e38 3D \u68c0\u6d4b\u5934\u6216\u5176\u4ed6\u4efb\u52a1\u6a21\u5757\u3002 \"\"\" # ===== 0. Virtual points (interface) ===== virtual_points = self . generate_virtual_points ( lidar_points , image = image , calib = calib ) # ===== Stage A: Voxel Preparation (torch.ops) ===== points = torch . ops . virconv . point_fusion ( # 1 lidar_points , virtual_points ) points = torch . ops . virconv . point_align ( # 2 points ) voxel_coords , voxel_features = torch . ops . virconv . voxelization ( # 3 points , self . voxel_size , self . point_cloud_range ) bin_ids = torch . ops . virconv . distance_binning ( # 4 voxel_coords , self . voxel_size , self . point_cloud_range , self . bin_edges ) voxel_coords , voxel_features = torch . ops . virconv . stvd_input ( # 5 voxel_coords , voxel_features , bin_ids , self . input_discard_rate ) # ===== Stage B/C: VirConv Block ===== voxel_coords , voxel_features = torch . ops . virconv . stvd_layer ( # 6 voxel_coords , voxel_features , self . layer_discard_rate , training ) feat_3d = self . nrconv3d ( voxel_features ) # 7 pixel_coords = torch . ops . virconv . projection ( # 8 voxel_coords , self . voxel_size , self . point_cloud_range , proj_matrix ) feat_2d = self . nrconv2d ( feat_3d , pixel_coords ) # 9 fused_feat = self . fusion ( feat_3d , feat_2d ) # 10 out_feat = self . spconv3d ( fused_feat ) # 11 return out_feat","title":"Framework"},{"location":"framework/#virconv-framework","text":"VirConv Framework \u7528\u4e8e \u7edf\u4e00\u7ec4\u7ec7\u5e76\u8c03\u5ea6\u5404\u9636\u6bb5\u7b97\u5b50\u4e0e\u6a21\u5757 \uff0c \u6784\u6210\u4ece\u70b9\u4e91\u8f93\u5165\u5230\u878d\u5408\u4f53\u7d20\u7279\u5f81\u8f93\u51fa\u7684\u5b8c\u6574\u524d\u5411\u8ba1\u7b97\u6d41\u7a0b\u3002 \u8be5\u6846\u67b6\u672c\u8eab\u4e0d\u5f15\u5165\u65b0\u7684\u8ba1\u7b97\u903b\u8f91\uff0c\u800c\u662f\u6309\u7167\u65e2\u5b9a\u987a\u5e8f\u4e32\u8054\u5404\u9636\u6bb5\u7b97\u5b50\u3002","title":"VirConv Framework\uff08\u6574\u4f53\u6846\u67b6\uff09"},{"location":"framework/#_1","text":"VirConv Framework \u4e3b\u8981\u7531\u4ee5\u4e0b\u90e8\u5206\u6784\u6210\uff1a Virtual Point Generator \u7528\u4e8e\u751f\u6210\u4f2a\u70b9\u4e91\uff08Demo \u4e2d\u53ef\u4f7f\u7528 Simple \u5b9e\u73b0\uff09\u3002 Voxel Preparation Stage \u5bf9\u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u8fdb\u884c\u878d\u5408\u4e0e\u4f53\u7d20\u5316\u5904\u7406\u3002 VirConv Stage \u6267\u884c VirConv Block \u7684\u6838\u5fc3\u8ba1\u7b97\u3002","title":"\u6846\u67b6\u7ec4\u6210"},{"location":"framework/#_2","text":"\u6846\u67b6\u5728\u524d\u5411\u8fc7\u7a0b\u4e2d\u4f9d\u6b21\u5b8c\u6210\u4ee5\u4e0b\u6b65\u9aa4\uff1a \u751f\u6210\u6216\u63a5\u6536\u4f2a\u70b9\u4e91 \u8c03\u7528 Voxel Preparation Stage \u6784\u5efa\u4f53\u7d20\u7ea7\u8f93\u5165 \u8c03\u7528 VirConv Stage \u8fdb\u884c\u7279\u5f81\u878d\u5408\u8ba1\u7b97 \u8f93\u51fa\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81","title":"\u524d\u5411\u6267\u884c\u6d41\u7a0b"},{"location":"framework/#api","text":"","title":"API \u6587\u6863"},{"location":"framework/#virconvframework","text":"Bases: Module VirConv Framework\u3002 \u8be5\u6846\u67b6\u7528\u4e8e\u5c06 VirConv \u65b9\u6cd5\u4e2d\u7684\u5404\u4e2a\u7b97\u5b50\u4e0e\u7f51\u7edc\u6a21\u5757\u6309\u7167\u65e2\u5b9a\u987a\u5e8f \u8fdb\u884c\u7ec4\u7ec7\u4e0e\u8c03\u5ea6\uff0c\u6784\u6210\u4ece LiDAR \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u8f93\u5165\u5230\u878d\u5408\u4f53\u7d20\u7279\u5f81\u8f93\u51fa\u7684 \u5b8c\u6574\u524d\u5411\u8ba1\u7b97\u6d41\u7a0b\u3002 \u672c\u6846\u67b6\u672c\u8eab\u4e0d\u5f15\u5165\u65b0\u7684\u51e0\u4f55\u6216\u878d\u5408\u903b\u8f91\uff0c\u800c\u662f\u4f5c\u4e3a\u4e00\u4e2a Pipeline / Orchestrator \uff0c \u4e32\u8054\u4ee5\u4e0b\u4e24\u4e2a\u4e3b\u8981\u9636\u6bb5\uff1a Voxel Preparation Stage\uff08\u4f53\u7d20\u51c6\u5907\u9636\u6bb5\uff09 VirConv Block Stage\uff08VirConv \u6838\u5fc3\u8ba1\u7b97\u9636\u6bb5\uff09 \u6240\u6709\u4e0d\u53ef\u5b66\u4e60\u7b97\u5b50\u5747\u901a\u8fc7 torch.ops.virconv.* \u5f62\u5f0f\u8c03\u7528\uff0c \u53ef\u5b66\u4e60\u6a21\u5757\u5219\u4ee5 nn.Module \u7684\u5f62\u5f0f\u6ce8\u518c\u5728\u6846\u67b6\u4e2d\u3002 Args: virtual_point_generator (VirtualPointGeneratorInterface): \u4f2a\u70b9\u4e91\u751f\u6210\u5668\u63a5\u53e3\uff0c\u7528\u4e8e\u4ece\u56fe\u50cf\u6216\u5176\u4ed6\u6a21\u6001\u4fe1\u606f\u4e2d\u751f\u6210\u865a\u62df\u70b9\u4e91\u3002 \u5728 Demo \u4e2d\u53ef\u4f7f\u7528 Simple \u5b9e\u73b0\u3002 voxel_size (Tuple[float, float, float]): \u4f53\u7d20\u5927\u5c0f (vx, vy, vz)\uff0c\u7528\u4e8e\u70b9\u4e91\u4f53\u7d20\u5316\u3002 point_cloud_range (Tuple[float, float, float, float, float, float]): \u70b9\u4e91\u7a7a\u95f4\u8303\u56f4 (x_min, y_min, z_min, x_max, y_max, z_max)\u3002 bin_edges (torch.Tensor): \u8ddd\u79bb\u5206\u7bb1\u7684\u8fb9\u754c\uff0c\u7528\u4e8e distance_binning \u7b97\u5b50\u3002 input_discard_rate (float): STVD \u8f93\u5165\u9636\u6bb5\u7684\u70b9\u4e91\u4e22\u5f03\u6bd4\u4f8b\uff0c\u7528\u4e8e\u6291\u5236\u5197\u4f59\u865a\u62df\u70b9\u3002 layer_discard_rate (float): STVD Layer \u5185\u90e8\u7684\u4f53\u7d20\u4e22\u5f03\u6bd4\u4f8b\u3002 feat_dim (int): \u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6\u3002 Source code in framework.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class VirConvFramework ( torch . nn . Module ): \"\"\" VirConv Framework\u3002 \u8be5\u6846\u67b6\u7528\u4e8e\u5c06 VirConv \u65b9\u6cd5\u4e2d\u7684\u5404\u4e2a\u7b97\u5b50\u4e0e\u7f51\u7edc\u6a21\u5757\u6309\u7167\u65e2\u5b9a\u987a\u5e8f \u8fdb\u884c\u7ec4\u7ec7\u4e0e\u8c03\u5ea6\uff0c\u6784\u6210\u4ece LiDAR \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u8f93\u5165\u5230\u878d\u5408\u4f53\u7d20\u7279\u5f81\u8f93\u51fa\u7684 \u5b8c\u6574\u524d\u5411\u8ba1\u7b97\u6d41\u7a0b\u3002 \u672c\u6846\u67b6\u672c\u8eab\u4e0d\u5f15\u5165\u65b0\u7684\u51e0\u4f55\u6216\u878d\u5408\u903b\u8f91\uff0c\u800c\u662f\u4f5c\u4e3a\u4e00\u4e2a **Pipeline / Orchestrator**\uff0c \u4e32\u8054\u4ee5\u4e0b\u4e24\u4e2a\u4e3b\u8981\u9636\u6bb5\uff1a - Voxel Preparation Stage\uff08\u4f53\u7d20\u51c6\u5907\u9636\u6bb5\uff09 - VirConv Block Stage\uff08VirConv \u6838\u5fc3\u8ba1\u7b97\u9636\u6bb5\uff09 \u6240\u6709\u4e0d\u53ef\u5b66\u4e60\u7b97\u5b50\u5747\u901a\u8fc7 `torch.ops.virconv.*` \u5f62\u5f0f\u8c03\u7528\uff0c \u53ef\u5b66\u4e60\u6a21\u5757\u5219\u4ee5 `nn.Module` \u7684\u5f62\u5f0f\u6ce8\u518c\u5728\u6846\u67b6\u4e2d\u3002 --- Args: virtual_point_generator (VirtualPointGeneratorInterface): \u4f2a\u70b9\u4e91\u751f\u6210\u5668\u63a5\u53e3\uff0c\u7528\u4e8e\u4ece\u56fe\u50cf\u6216\u5176\u4ed6\u6a21\u6001\u4fe1\u606f\u4e2d\u751f\u6210\u865a\u62df\u70b9\u4e91\u3002 \u5728 Demo \u4e2d\u53ef\u4f7f\u7528 Simple \u5b9e\u73b0\u3002 voxel_size (Tuple[float, float, float]): \u4f53\u7d20\u5927\u5c0f (vx, vy, vz)\uff0c\u7528\u4e8e\u70b9\u4e91\u4f53\u7d20\u5316\u3002 point_cloud_range (Tuple[float, float, float, float, float, float]): \u70b9\u4e91\u7a7a\u95f4\u8303\u56f4 (x_min, y_min, z_min, x_max, y_max, z_max)\u3002 bin_edges (torch.Tensor): \u8ddd\u79bb\u5206\u7bb1\u7684\u8fb9\u754c\uff0c\u7528\u4e8e distance_binning \u7b97\u5b50\u3002 input_discard_rate (float): STVD \u8f93\u5165\u9636\u6bb5\u7684\u70b9\u4e91\u4e22\u5f03\u6bd4\u4f8b\uff0c\u7528\u4e8e\u6291\u5236\u5197\u4f59\u865a\u62df\u70b9\u3002 layer_discard_rate (float): STVD Layer \u5185\u90e8\u7684\u4f53\u7d20\u4e22\u5f03\u6bd4\u4f8b\u3002 feat_dim (int): \u4f53\u7d20\u7279\u5f81\u7ef4\u5ea6\u3002 \"\"\" def __init__ ( self , virtual_point_generator : VirtualPointGeneratorInterface , voxel_size : Tuple [ float , float , float ], point_cloud_range : Tuple [ float , float , float , float , float , float ], bin_edges : torch . Tensor , input_discard_rate : float , layer_discard_rate : float , feat_dim : int ): super () . __init__ () self . virtual_point_generator = virtual_point_generator self . voxel_size = torch . tensor ( voxel_size , dtype = torch . float32 ) self . point_cloud_range = torch . tensor ( point_cloud_range , dtype = torch . float32 ) self . bin_edges = bin_edges self . input_discard_rate = input_discard_rate self . layer_discard_rate = layer_discard_rate # ===== \u53ef\u5b66\u4e60\u6a21\u5757 ===== self . nrconv3d = NRConv3D ( feat_dim , feat_dim ) self . nrconv2d = NRConv2D ( feat_dim , feat_dim ) self . fusion = FeatureFusion ( feat_dim , feat_dim , feat_dim ) self . spconv3d = SparseConv3D ( feat_dim , feat_dim ) def forward ( self , lidar_points : torch . Tensor , image : Optional [ torch . Tensor ] = None , calib : Optional [ dict ] = None , proj_matrix : Optional [ torch . Tensor ] = None , training : bool = True ): \"\"\" \u6267\u884c\u5b8c\u6574\u7684 VirConv \u524d\u5411\u6d41\u7a0b\u3002 \u8be5\u51fd\u6570\u6309\u7167 VirConv \u7684\u6807\u51c6\u8ba1\u7b97\u987a\u5e8f\uff0c\u4f9d\u6b21\u5b8c\u6210\uff1a 1. \u4f2a\u70b9\u4e91\u751f\u6210 2. \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u878d\u5408 3. \u4f53\u7d20\u5316\u4e0e STVD \u8f93\u5165\u6784\u5efa 4. VirConv Block \u6838\u5fc3\u8ba1\u7b97 5. \u8f93\u51fa\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81 --- Args: lidar_points (torch.Tensor): \u8f93\u5165 LiDAR \u70b9\u4e91\uff0cshape \u4e3a (N, C)\uff0c \u7531\u6570\u636e\u96c6\u6216 3D \u68c0\u6d4b\u5668\u9884\u5904\u7406\u6a21\u5757\u63d0\u4f9b\u3002 image (torch.Tensor, optional): \u8f93\u5165\u56fe\u50cf\u6570\u636e\uff0c\u7528\u4e8e\u4f2a\u70b9\u4e91\u751f\u6210\u6216 2D \u6295\u5f71\u76f8\u5173\u8ba1\u7b97\u3002 \u5728 Fake Demo \u4e2d\u53ef\u4e3a None\u3002 calib (dict, optional): \u6807\u5b9a\u53c2\u6570\u5b57\u5178\uff0c\u901a\u5e38\u5305\u542b LiDAR \u4e0e Camera \u4e4b\u95f4\u7684\u5916\u53c2\u53ca\u6295\u5f71\u77e9\u9635\u3002 proj_matrix (torch.Tensor, optional): 3D \u2192 2D \u6295\u5f71\u77e9\u9635\uff0c\u7528\u4e8e projection \u7b97\u5b50\u3002 training (bool): \u662f\u5426\u5904\u4e8e\u8bad\u7ec3\u9636\u6bb5\uff0c\u7528\u4e8e\u63a7\u5236 STVD Layer \u4e2d\u7684\u968f\u673a\u4e22\u5f03\u884c\u4e3a\u3002 --- Returns: out_feat (torch.Tensor): \u878d\u5408\u540e\u7684\u7a00\u758f\u4f53\u7d20\u7279\u5f81\uff0c\u4f5c\u4e3a VirConv Block \u7684\u6700\u7ec8\u8f93\u51fa\uff0c \u53ef\u76f4\u63a5\u5bf9\u63a5\u4e0b\u6e38 3D \u68c0\u6d4b\u5934\u6216\u5176\u4ed6\u4efb\u52a1\u6a21\u5757\u3002 \"\"\" # ===== 0. Virtual points (interface) ===== virtual_points = self . generate_virtual_points ( lidar_points , image = image , calib = calib ) # ===== Stage A: Voxel Preparation (torch.ops) ===== points = torch . ops . virconv . point_fusion ( # 1 lidar_points , virtual_points ) points = torch . ops . virconv . point_align ( # 2 points ) voxel_coords , voxel_features = torch . ops . virconv . voxelization ( # 3 points , self . voxel_size , self . point_cloud_range ) bin_ids = torch . ops . virconv . distance_binning ( # 4 voxel_coords , self . voxel_size , self . point_cloud_range , self . bin_edges ) voxel_coords , voxel_features = torch . ops . virconv . stvd_input ( # 5 voxel_coords , voxel_features , bin_ids , self . input_discard_rate ) # ===== Stage B/C: VirConv Block ===== voxel_coords , voxel_features = torch . ops . virconv . stvd_layer ( # 6 voxel_coords , voxel_features , self . layer_discard_rate , training ) feat_3d = self . nrconv3d ( voxel_features ) # 7 pixel_coords = torch . ops . virconv . projection ( # 8 voxel_coords , self . voxel_size , self . point_cloud_range , proj_matrix ) feat_2d = self . nrconv2d ( feat_3d , pixel_coords ) # 9 fused_feat = self . fusion ( feat_3d , feat_2d ) # 10 out_feat = self . spconv3d ( fused_feat ) # 11 return out_feat","title":"VirConvFramework"},{"location":"framework/#framework.VirConvFramework.forward","text":"\u6267\u884c\u5b8c\u6574\u7684 VirConv \u524d\u5411\u6d41\u7a0b\u3002 \u8be5\u51fd\u6570\u6309\u7167 VirConv \u7684\u6807\u51c6\u8ba1\u7b97\u987a\u5e8f\uff0c\u4f9d\u6b21\u5b8c\u6210\uff1a 1. \u4f2a\u70b9\u4e91\u751f\u6210 2. \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u878d\u5408 3. \u4f53\u7d20\u5316\u4e0e STVD \u8f93\u5165\u6784\u5efa 4. VirConv Block \u6838\u5fc3\u8ba1\u7b97 5. \u8f93\u51fa\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81 Args: lidar_points (torch.Tensor): \u8f93\u5165 LiDAR \u70b9\u4e91\uff0cshape \u4e3a (N, C)\uff0c \u7531\u6570\u636e\u96c6\u6216 3D \u68c0\u6d4b\u5668\u9884\u5904\u7406\u6a21\u5757\u63d0\u4f9b\u3002 image (torch.Tensor, optional): \u8f93\u5165\u56fe\u50cf\u6570\u636e\uff0c\u7528\u4e8e\u4f2a\u70b9\u4e91\u751f\u6210\u6216 2D \u6295\u5f71\u76f8\u5173\u8ba1\u7b97\u3002 \u5728 Fake Demo \u4e2d\u53ef\u4e3a None\u3002 calib (dict, optional): \u6807\u5b9a\u53c2\u6570\u5b57\u5178\uff0c\u901a\u5e38\u5305\u542b LiDAR \u4e0e Camera \u4e4b\u95f4\u7684\u5916\u53c2\u53ca\u6295\u5f71\u77e9\u9635\u3002 proj_matrix (torch.Tensor, optional): 3D \u2192 2D \u6295\u5f71\u77e9\u9635\uff0c\u7528\u4e8e projection \u7b97\u5b50\u3002 training (bool): \u662f\u5426\u5904\u4e8e\u8bad\u7ec3\u9636\u6bb5\uff0c\u7528\u4e8e\u63a7\u5236 STVD Layer \u4e2d\u7684\u968f\u673a\u4e22\u5f03\u884c\u4e3a\u3002 Returns: out_feat (torch.Tensor): \u878d\u5408\u540e\u7684\u7a00\u758f\u4f53\u7d20\u7279\u5f81\uff0c\u4f5c\u4e3a VirConv Block \u7684\u6700\u7ec8\u8f93\u51fa\uff0c \u53ef\u76f4\u63a5\u5bf9\u63a5\u4e0b\u6e38 3D \u68c0\u6d4b\u5934\u6216\u5176\u4ed6\u4efb\u52a1\u6a21\u5757\u3002 Source code in framework.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def forward ( self , lidar_points : torch . Tensor , image : Optional [ torch . Tensor ] = None , calib : Optional [ dict ] = None , proj_matrix : Optional [ torch . Tensor ] = None , training : bool = True ): \"\"\" \u6267\u884c\u5b8c\u6574\u7684 VirConv \u524d\u5411\u6d41\u7a0b\u3002 \u8be5\u51fd\u6570\u6309\u7167 VirConv \u7684\u6807\u51c6\u8ba1\u7b97\u987a\u5e8f\uff0c\u4f9d\u6b21\u5b8c\u6210\uff1a 1. \u4f2a\u70b9\u4e91\u751f\u6210 2. \u70b9\u4e91\u4e0e\u4f2a\u70b9\u4e91\u878d\u5408 3. \u4f53\u7d20\u5316\u4e0e STVD \u8f93\u5165\u6784\u5efa 4. VirConv Block \u6838\u5fc3\u8ba1\u7b97 5. \u8f93\u51fa\u878d\u5408\u540e\u7684\u4f53\u7d20\u7279\u5f81 --- Args: lidar_points (torch.Tensor): \u8f93\u5165 LiDAR \u70b9\u4e91\uff0cshape \u4e3a (N, C)\uff0c \u7531\u6570\u636e\u96c6\u6216 3D \u68c0\u6d4b\u5668\u9884\u5904\u7406\u6a21\u5757\u63d0\u4f9b\u3002 image (torch.Tensor, optional): \u8f93\u5165\u56fe\u50cf\u6570\u636e\uff0c\u7528\u4e8e\u4f2a\u70b9\u4e91\u751f\u6210\u6216 2D \u6295\u5f71\u76f8\u5173\u8ba1\u7b97\u3002 \u5728 Fake Demo \u4e2d\u53ef\u4e3a None\u3002 calib (dict, optional): \u6807\u5b9a\u53c2\u6570\u5b57\u5178\uff0c\u901a\u5e38\u5305\u542b LiDAR \u4e0e Camera \u4e4b\u95f4\u7684\u5916\u53c2\u53ca\u6295\u5f71\u77e9\u9635\u3002 proj_matrix (torch.Tensor, optional): 3D \u2192 2D \u6295\u5f71\u77e9\u9635\uff0c\u7528\u4e8e projection \u7b97\u5b50\u3002 training (bool): \u662f\u5426\u5904\u4e8e\u8bad\u7ec3\u9636\u6bb5\uff0c\u7528\u4e8e\u63a7\u5236 STVD Layer \u4e2d\u7684\u968f\u673a\u4e22\u5f03\u884c\u4e3a\u3002 --- Returns: out_feat (torch.Tensor): \u878d\u5408\u540e\u7684\u7a00\u758f\u4f53\u7d20\u7279\u5f81\uff0c\u4f5c\u4e3a VirConv Block \u7684\u6700\u7ec8\u8f93\u51fa\uff0c \u53ef\u76f4\u63a5\u5bf9\u63a5\u4e0b\u6e38 3D \u68c0\u6d4b\u5934\u6216\u5176\u4ed6\u4efb\u52a1\u6a21\u5757\u3002 \"\"\" # ===== 0. Virtual points (interface) ===== virtual_points = self . generate_virtual_points ( lidar_points , image = image , calib = calib ) # ===== Stage A: Voxel Preparation (torch.ops) ===== points = torch . ops . virconv . point_fusion ( # 1 lidar_points , virtual_points ) points = torch . ops . virconv . point_align ( # 2 points ) voxel_coords , voxel_features = torch . ops . virconv . voxelization ( # 3 points , self . voxel_size , self . point_cloud_range ) bin_ids = torch . ops . virconv . distance_binning ( # 4 voxel_coords , self . voxel_size , self . point_cloud_range , self . bin_edges ) voxel_coords , voxel_features = torch . ops . virconv . stvd_input ( # 5 voxel_coords , voxel_features , bin_ids , self . input_discard_rate ) # ===== Stage B/C: VirConv Block ===== voxel_coords , voxel_features = torch . ops . virconv . stvd_layer ( # 6 voxel_coords , voxel_features , self . layer_discard_rate , training ) feat_3d = self . nrconv3d ( voxel_features ) # 7 pixel_coords = torch . ops . virconv . projection ( # 8 voxel_coords , self . voxel_size , self . point_cloud_range , proj_matrix ) feat_2d = self . nrconv2d ( feat_3d , pixel_coords ) # 9 fused_feat = self . fusion ( feat_3d , feat_2d ) # 10 out_feat = self . spconv3d ( fused_feat ) # 11 return out_feat","title":"forward"}]}